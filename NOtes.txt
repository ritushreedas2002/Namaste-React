-------------------------------------------------EPISODE 1--------------------------------------------------------------------------------
CDN LINKS FOR REACT:
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script type="module" src="./app.js"></script>

CDN :    "CDN" stands for Content Delivery Network. CDNs are networks of distributed servers
that work together to deliver web content, such as images, stylesheets, JavaScript files, and other assets

crossorigin: 
1. Browser security rule preventing requests to different domains.
2. to request the browser to fetch such resources 
with CORS (Cross-Origin Resource Sharing) headers. (Mechanism allowing servers to specify resource access permissions.)

NOTE: The order of the links should be maintained
-----
LINK 1: USE : Suitable for development environments with useful warnings and error messages for developers. 
It includes extra checks and debugging information.

LINK2 : USE :  Used in development environments along with React. It includes additional functionality related to 
rendering React components in the DOM.



-------------------------------------------------EPISODE 2--------------------------------------------------------------------------------

//React.createElement=>Object=>HTML

npm install -D parcel  //-D is a flag for dev dependency
npm -package  
dependency- The dependencies object specifies the packages that you need to run your code.


dependency---1.dev dependency (in development phase)   2. normal dependency (in development phase + production phase)
^-caret (automatic minor upgrades e.g. version 2.8.3 to 2.8.4)
~-tilde (for major upgrades e.g. 2.8.3 to 3.0.0)


package.json - mainly the version of packages that the npm is handling (also the changes from minor to major) (configuration for our npm)
package-lock.json - keeps track of the exact version of all the dependencies
node modules-data base or collection of dependencies


npm install parcel (beast)
we need parcel-->parcel depends on its other dependencies-->this nesting of dependencies is known as a transitive dependency


.gitignore---blocks all those files mentioned in it from uploading into the git repo (contains all the files that I don't want to push into GitHub)

We should not put the node modules into the production (no need to upload them)
that is why package.json and package-lock.json are necessary to be uploaded (because they maintain a note of all those dependencies our project needs), as they help in regenerating the required node modules for our project
we just need to do "npm install" and it will recreate all those node modules for us

npx parcel indexReact.html --will provide a server for our app
npx - executing a package


cdn links are not a preferred way to bring React and ReactDOM into our project - as it is a network-costly operation and React version control becomes difficult
"npm install" is the same as "npm i"

Features of Parcel--
-creates a Dev Build for you
-creates a Local server for you
-does HMR = Hot Module Replacement (exchanges, adds, or removes modules while an application is running, without a full reload)
-this HMR is done by File Watching Algorithm - written in C++
-does Caching (in .parcel-cache folder)- which provides Faster Builds 
-does Image optimization
-does Minification which is essential for production build
-does Bundling
-does Compressing
-does Consistent Hashing
-does Code Splitting for you
-gives Differential Bundling to our app (so that our app runs smoothly on older browser versions as well)
-gives Diagnostics of our app
-provides good error handling (better error suggestions)
-HTTPS
-does Tree Shaking Algorithm -  analyze the import, and export of each module, and remove everything that isn't used
-different dev and prod bundles

"npx parcel indexReact.html"
when you write this, it generates a development build of your project and hosts it into port:1234 (which comes from the "dist" folder)

when we refresh the page or save files, it uses the ".parcel-cache" and "dist" folders to update the webpage using HMR

The "dist" and the ".parcel-cache" folders can be automatically generated on each build, thus they are not required to be put into GitHub

you can create a production build in the following way-
"npx parcel build indexReact.html"
//this will build a bundle(or minify), and it will put all those files into a new folder i.e. "dist" folder (that are production-ready files for the app)
//note: before writing this, from package.json delete the "main" key (else there may be a conflict)

** Local project does not directly connect with the Server
** Local pushes its code into the git (like package.json & package-lock.json is pushed and not the node-modules)
** Server then fetches the code from the git (fetches the package.json & package-lock.json to create the node-modules)
** The Server then hosts the code to the end-user
** The copy of node-modules in the Local is different from the copy of node-modules in the Server

inside package.json we configure browserslist(this tells about all the systems our app is compatible with):-
browserslist:[
    "last 2 Chrome versions",
    "last 2 Firefox versions"
] //the last 2 versions of Chrome and Firefox will definitely support our app
* "last 2 versions" - this will cover the last 2 versions of all the systems

-------------------------------------------------EPISODE 3--------------------------------------------------------------------------------

we can configure the scripts in the package.json:-
scripts are industry standards to shorten repetitive codes for starting/building our project
"scripts": {
    "start": "parcel indexReact.html",    [DEVELOPEMENT PHASE]
    "build": "parcel build indexReact.html"
  },

we can use the scripts in the terminal as follows:-
  npm run start or npm start are the same
  but npm build will not work like this, you need to write npm run build

** React.createElement => creates a ReactElement which is a JS Object => when we render this, the ReactDOM converts it into an HTMLElement and pushes it into the browser (and replaces everything from that DOM element if there was anything earlier)

 a. const parent1 = React.createElement("div", { id: "parent" },"HII")
  it isn't easy to create elements like this
  so JSX came into play -- a convention where HTML and JS are merged into one file  (JSX and React are not related to each other, e.g.- "JSX is a part of React" this statement is wrong)
** JSX is not "HTML inside Javascript"
   it is simply an "HTML-like syntax" or "XML-like syntax"
 b. const parent1 = <h1 id="parent"> HII </h1>;  //here parent1 is a React element
a. is a React element created using React, b. is a React element created using JSX (both these are the same thing)
b. is not pure JavaScript, our browser does not understand JSX
  ES6(ECMAScript) is what the JS engine understands   
  so Parcel does the whole thing that is JSX is transpiled before it reaches the JS engine (this JSX is converted into the code that our browser or the React can understand)
    but Parcel is not doing the transpilation by itself, it is putting another package called Babel (another JS library, Babel is a JS compiler) into work for this purpose
Parcel is a manager of Babel

During transpilation, internally the JSX is converted into a React.createElement done by Babel, and further methods are followed as usual

const heading=<h1 id="heading" className="hello">hii everyone</h1>; //this is not HTML, in HTML the attribute is "class", whereas that same attribute in JSX is "className"
** If you have to give an attribute in JSX, you have to write it in CamelCase, in HTML we write tabindex="1" in JSX we write tabIndex="1"
const  root=ReactDOM.createroot(document.getElementById("root"));
root.render(heading);

for multiline JSX code, you have to wrap it inside parentheses(), in order to help Babel understand where JSX is starting and ending
const heading=(
    <h1 id="heading" className="hello">
        hii everyone
    </h1>
);


//components   
1. Class-based components - old way (uses JS classes)
2. Functional components - new way (uses JS functions) //normal javascript function which returns some JSX element

const head1 = ()=>{
    return <h1 className="heading"> Namaste React Functional Component </h1>;
};

const head2 = ()=> <h1 className="heading"> Namaste React Functional Component </h1>;

const head3 = ()=> (
    <h1 className="heading"> Namaste React Functional Component </h1>
);
** head1, head2, head3 are the same React component

** You cannot render a functional component just like a React Element
root.render(<head1/>); //this is how to render a functional component

//Component Composition - component inside another Component
const Heading = ()=>{
    return <div id="root">
        <head1/>              // you can also write <head1></head1>  and also {head1()} -> this is like calling the head1() function
        <h1>HII EVERYONE</h1>
    </div>;
};

** You can also write normal JS functions to create functional components

const elem = <span>Hello Javascript code</span>; // consider elem as just a normal javascript variable
const heading = (
    <h1 id="heading" className="hello">
        {elem}               //This is how you can put a React Element inside another React Element
        hii everyone
    </h1>
);
const num=1000;
const data=api.getData();
const Heading = ()=>{
    return <div id="root">
        {data}                // inside these curly braces you can write any JS code/expression inside JSX
        <h2>{num}</h2>        // it will show 1000
        {heading}             // you can also put React Elements inside a functional component like this
        <h1>HII EVERYONE</h1>
    </div>;
};
* You can also put functional components inside a React element, just like a component inside another component

** Cross-site scripting is the attack technique that allows attacker to run JS code to access everything on your browser
like they can steal ur local storage data, cookies, read data
  *  JSX takes care of this injection, If the malicious API passes data to your code JSX just escapes it (sanitizing the data)

-------------------------------------------------EPISODE 4--------------------------------------------------------------------------------

** For INLINE STYLING in JSX,it takes a JS object as an attribute
--------------------------------------

const stylecard={
    background-color:"yellow";
}                                   // this is a JS object

const Body = () => {
  return (
    <div className='body'>
      <div className='search'>Search</div>
      <div className='res-container' style={stylecard}>  //objects can be written within curly braces (JS code/expression are written within curly braces inside JSX)
        <RestCard />                         |
      </div>                                 |
    </div>                           //INLINE STYLING in JSX
  );
}

<div className='res-container' style={{background-color:"yellow";}}>   // writing the JS object directly
//first { } telling there is some piece of JS inside it and second { } is the JS obj itself

** Passing a Prop to a component is just like passing an argument to a function
** React wraps up all the props together and passes them as an object to the required functional component
** When you have to dynamically pass in some data to a component, you pass in as a prop
** You can pass any no. of props you wish to, React will wrap them into an object

const RestaurantCard = (props) =>{
    return (
        <div className="res-card">
            <h3>{props.resName}</h3>
            <h4>{props.cuisine}</h4>
        </div>
    );
};

const Body = () =>{
    return (
        <div className="res-container">
            <RestaurantCard resName="Meghna Foods" cuisine="Indian"/>
            <RestaurantCard resName="KFC" cuisine="Burger"/>
            <RestaurantCard resName="Tabdoor's" cuisine="Arabic"/>
        </div>
    );
};

** You can also de-structure(JS concept) the object on the fly

const RestaurantCard = ({resName,cuisine}) =>{
    return (
        <div className="res-card">
            <h3>{resName}</h3>
            <h4>{cuisine}</h4>
        </div>
    );
};

OR

const RestaurantCard = (props) =>{
    const {resName,cuisine} = props;
    return (
        <div className="res-card">
            <h3>{resName}</h3>
            <h4>{cuisine}</h4>
        </div>
    );
};

----REAL DATA is in JSON format----------

** Config-driven UI -> opens swiggy with offers available in Bengaluru, Kolkata all are different
** Config-driven UI means your UI is driven by a particular configuration based upon certain conditions
It is necessary for not building diff UI for different places

Config comes from backend
---------------JSON------------------
{
"employee": {
"name": "sonoo",
"salary": 56000,
"married": true.
}
}
-----------------------------------------

swiggy api:https://www.swiggy.com/dapi/restaurants/list/v5?lat=12.9351929&lng=77.62448069999999&page_type=DESKTOP_WEB_LISTING

** const {cloudinaryImageId, name, avgRating, cuisines, costForTwo, deliveryTime} = resData?.data;  // this question mark(?) is called optional chaining

** DURING USING MAP:
--------------------
we need to write a key to uniquely identify the elements:-> Each child in a list should have a unique "key" prop. "key" is a reserved keyword.

                CONTAINER (root) 
     ----------------------------------                   
     |               |                |
1.component1    2.component2    3.component3
suppose you want to insert a component before component0 in the first place, this is where the key is important
key is also important as because of it, React will know which component is new, and it will not re-render everything again, otherwise, React won't know which component came at which position, and it will clean the container, and re-render everything (as it considers all the components as same)

When React renders a list of elements, it needs a way to identify each item in the list uniquely. The key prop provides 
a hint to React about the identity of each element. This is especially important when the list can dynamically change, such as 
when items are added or removed.

** Keys optimize our code heavily (big performance enhancement)

data.map((rest,index) => (
    <ResCard key={index} data={rest} />   //key is to identify each card as unique
))
//INDEX is not recommended by React itself to be used as keys

// not using keys (not acceptable) <<<< index as key <<<<<<<< unique id (best practice)

-------------------------------------------------EPISODE 5--------------------------------------------------------------------------------
src folder has the source code

** keep all your components in the 'components' folder

** It is better to always name the file the same as the component it contains, like the Header component in the Header.js file
** Before you can import a component, you have to export that component from the file it resides in

import Header from "./components/Header"; is the same as import Header from "./components/Header.js"; or import Header from "./components/Header.jsx"; based upon what extension you give to your file because React will treat it as a JS file by itself

** ALL hard-coded data like links and dummy data are placed in another folder called 'utils' or 'common' or 'config' and not in the 'components' folder
you can keep your constant links in the constant.js file (small c denotes it is not a component)

Types of EXPORT/IMPORT 
1. Default (Components)
--------export default component_name;
--------import component_name from './path_name';
** In one file, you can only have one default export

2. Named (for multiple exports)
--------export const constant_name = // write the constant value
--------export const constant_name2 = // write the constant value
--------import {name, name2} from './path_name';
** A good practice is to keep default export for components, but you can do named export for components also

Default export can be done with the named export in this format:---------------

// Named export
export const myFunction = () => {
  // ... function implementation
};

// Default export
const MyComponent = () => {
  // ... component implementation
};
export default MyComponent;

onClick takes a call-back function 
----------
<button className="filter-btn" onClick={()=>{}}>Top Rated Restaurants</button>  
/*button has an onClick attribute, which takes in a callback function(this is the function that will be called on click) */

REACT HOOKS  (//import from react as a named import)
===========
NOTE: when we change a normal variable it does not affect the UI so we use the Hooks.
Hooks are normal JS functions given by React for specific use cases. They have superpowers used for DOM manipulation
These are the utility functions given by React. The two important hooks are : useState() and useEffect()

useState() - gives you a superpowerful React variable that keeps sync of the data layer and UI layer
** import { useState } from "react";
useState() is used to create a State variable (it maintains the state of your component)
whenever you call the useState() function, it gives a state variable, which you must receive.
const [listOfRestaurants] = useState([]); // listOfRestaurants receives the array returned by useState(), whatever we pass inside useState() becomes the default value of the State variable, [] (empty list) in this case

const [listOfRestaurants, setListOfRestaurants] = useState(reslist);
           |                       |                           |
     main variable          what to be placed           default value[array of objects]
                           when an event occurs          of main var
                    (preferred convention to add set
                      before the main variable name)
                    ** Updates the main variable, and
                      reflects the changes in the UI

setListOfRestaurants(filteredList);
means that listOfRestaurants = filteredList; after onCLick eventListener

this will filter out those restaurants having a rating of more than 4 and sets the listOfRestaurants to filteredList
This is called re-rendering. When a state variable changes react re-renders its components. As soon as the list of restaurants updates,
React will very quickly remove the past data and update the UI with the new data.
The logic of re-rendering is basically updating the UI

 const arr = useState(resList);     //array destructuring //useState is returning an array

 const [listOfRestaurants, setListOfRestaurants] = arr;
OR
 const listOfRestaurants = arr[0];
 const setListOfRestaurants = arr[1];

** useState() always returns an array of 2 parameters, first is the initial value assigned to a variable, second is the setter function used to change/update the original variable

** In the "const" data type we cannot change the value, but how is it possible?
When we update the value by assigning a new value to setListOfRestaurants then the useState() actually rerenders the whole component 
so a new value is assigned to listOfRestaurants.

Reconciliation Algorithm(also known as React Fibre)
---------------------------------------------------

Actual DOM (only code)             Virtual DOM is the representation of the actual DOM, it is nothing but the JS object
<div>
  <div>
    <h1/>
  </div>
</div>

DIFF Algorithm
-----------------

It will calculate the difference between the previous obj and the updated obj then it changes(updates) the DOM and renders it at every render cycle. 
Whenever there is a change in state variable there is a change in DOM and react re-renders.

React is fast-> because it does efficient DOM manipulation-> in Virtual DOM
** Finding out the difference between two HTML codes is tough, Finding out the difference between two objects (virtual DOM) is fast

--------------------------------------------------------------EPISODE 6--------------------------------------------------------------------------------

Architecture---
------------------

1. MONOLITH Architecture (Suppose this is a JAVA PROJECT and we are doing everything in that project)

|---------------------|
| API   UI     AUTH   |  (JAVA PROJ)  (only written in Java)
| DB     SMS          |
|---------------------|

2. MICROSERVICES

Different services for different jobs    
|--------------------------|
|                          |
|  |API|     |UI|   |DB|   |(theses services are independent of each other and interacts in some use cases)
|                          |     (All these small applications are performed separately following the separation of concerns (single responsibility principle))
|   |AUTH|   |SMS|         |
|--------------------------|

How do these services interact with each other?
these services interact with each other through different cases. They make calls to different microservices.
Our react project comes into UI  microservices. ADVANTAGE: is that UI can be written in react, backend can be written in Mongodb 
so  mainly different microservices can be written in different languages. They run in their own ports. eg UI:1234, Backend:1022, and all these
ports are mapped to their domain name.  


TWO APPROACHES OF API CALL :
---------------------------------
1.
LOADS --> API CALL(takes 500ms)-->Renders it in UI
(as soon as the page loads we make an API call, the API response and we render it )
(poor user experience as we need to wait for 500ms)

2.
LOADS --> RENDERS -->API CALL --->RE-RENDERS
(as soon as the page loads we render it then we make an API call, the API response and we re-render it )
(Best approach)

useEffect() hook 
-------------------------
it takes two arguments:- 1. callback function 2. dependency array
After the whole component loads, and the render cycle is over, it calls its callback function. 
(useEffect's callback function gets called after the component has been rendered, as soon as the render cycle has finished)

eg.
-----
useEffect(()=>{
  console.log("HII");   // this will be called after the whole Body component's render cycle has finished
},[]);
 console.log("Ritu");   // this will be called during rendering Body component 

 console
 ----------
 Ritu
 HII

const fetchData = async () => {
    const data = await fetch( "API" );     // this fetch() is provided to us by the browser or the JS engine,  it fetches data from the API, and this fetch() will return a promise
    const json = await data.json();
};
//You can handle a promise by either using .then - .catch or by using async - await(modern approach)

CORS policy: mainly our browser is not allowing us to call Swiggy's API from the local host, it restricts the calling of an API from one origin to another origin

how to find API? : go to website ->inspect->network->click on fetch option->left side column API are given

Suppose instead of showing the Loading page while the API does response and re-renders we can show a spinning loader or shimmer UI which is the shadow of the whole original UI.

const [button,setbutton]=useState("Login");

how the const variable is changed?
so when we click "Login", setbutton function executes, and React ensures to find the difference between the previous virtual DOM and the modified virtual DOM and then re-renders the 
component once again, so again a new button variable is created with the modified value.
** And this is why we need a State variable because a normal variable would only change its value without affecting the UI, but for a State variable, the data layer and the UI layer are closely connected, thus reflecting the changes in sync with one another.

const [searchtext, setsearchtext] = useState("");
<input type='text' className='search-box' value={searchtext}></input>   
We need to bind the input with a local state variable to keep track of the input that the user types in.

NOTE: when at each keystroke nothing shows in the input text this is because .... the 'value' is tied/bind to 'searchtext' and the 'input' box is tied/bind to the 'searchtext'
so even if we try to change the value in the input box, it still remains the same as the searchtext is still ""

** So we need to add an onChange event handler:---so that as the input changes, the searchtext value also changes 
at each keystroke, the react component gets rendered again and again

** Whenever a state variable updates, react triggers a reconciliation cycle(re-renders the component).
React is re-rendering the whole component but it is only updating the input box value inside the DOM

** React is so fast because it does DOM manipulation with high efficiency, because of the new reconciliation algorithm, whenever React has to re-render a component, it only updates the part that is getting changed by comparing the past and present virtual DOM

NOTE:
-------
const [listOfRestaurants, setListOfRestaurants] = useState([]);
const [filteredlistOfRestaurants, setfilteredListOfRestaurants] = useState([]);

we are keeping intact the main list of restaurants, that is, listOfRestaurants, and on every change, we are manipulating filteredlistOfRestaurants
so that the main list of restaurants remains intact otherwise if our main list gets updated, then for all the following searches after that, it will search only within the updated list, and not the original list
this way we never update our original list of restaurants, i.e., listOfRestaurants, except for the first time, while fetching data from the API

--------------------------------------------------------------EPISODE 7--------------------------------------------------------------------------------

useEffect
------------
1. useEffect(()=>{}), if no dependency array is given, then useEffect will be called at every render of the component.
2. useEffect(()=>{},[]) If the dependency is an empty array, then useEffect will be called at the first render of the component(just once).
3. useEffect(()=>{},[btnname]) If the dependency is not an empty array, then useEffect will be called when the btnanme variable gets updated

useState
-----------
useState() is used to create local state variables inside your functional component (so always call it inside your functional component, and always call it at the top of your component(preferred))
NOTE: do not create state variables inside conditional statements(if-else)(otherwise it creates inconsistencies) or for loops or functions.

useContext
----------------
It is state managemnet hook suppose i want to use a variable count in various component. Instead of props drilling we can accessit directly through useContext.

>Context>Context.js
import {createContext} from 'react'
export const counterContext=createContext(0); //initial value

App.js
-----------
//////Those components which are surrounded ny the provider can acces the counterContext
import {counterContext} from "/context/context.js"
const app=()=>{
    const[count,setcount]=useState(0);
    return (
        <counterContext.Provider value={{count,setcount}}>  //value will the state value which we wanted to pass
            <Navbar/>
            <Component1/>
        </counterContex.Provider>
    )
}

Component.js
--------------
import {counterContext} from "context/context.js"
import {useContext} from "react"
const component=()=>{
    const counter=useContext(useContext);
    return (
        <h1>
            {counter.count}
        </h1>
        <button onClick={()=>counter.setcount(counter.count+1)}/> //to change the value also on click on the button
    )
}



** npm i -D react-router-dom
npm react-router-dom is installed to access the router facility to enhance the multi-page concept
e.g if I write /about in url we will redirect to the about us page

createBrowserRouter() creates an Router configuration(means some information that will define what will happen on a specific route)
---------------------
createBrowserRouter([{},{}]) takes a list of objects where each object is given its path and the element to be rendered at that specific path.

RouterProvider is used to provide the createBrowserRouter and change pages based on the required path
--------------
import { createBrowserRouter,RouterProvider } from 'react-router-dom';
 
const appRouter = createBrowserRouter([
  {
    path:"/",
    element:<App/>
  },
  {
    path:"/about",
    element:<About/>
  }
])

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
 <RouterProvider route={appRouter}/>
);

** rafce -> shortcut for creating basic functional components and exporting them

** 'react-router-dom' already provides a default error page for you, which is used in case some other error page is not created explicitly

** Another important hook is useRouteError, which gives more details about the different types of errors that can occur
import { useReactError } from 'react-router-dom';

you can catch the error like this ->
const err = useReactError();   // this returns an object that contains all the details of the error that occurs in the current page
console.log(err);

Another approach:
-------------------

<Router>: This is a component from React Router that provides the routing context for your application. It must wrap the entire application to enable routing.

<Routes>: This component is used to define the routes for your application. Inside it, you specify the different routes using the <Route> component.

<Route path="/" element={<App />} />: This line defines a route for the root path ("/"). When the URL matches "/", it renders the <App /> component.
 The element prop is used to specify the component to render for the given route.

import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
 const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <Router>
    <Routes>
      <Route path="/" element={<App />} />
      <Route path="/about" element={<About />} />
    </Routes>
  </Router>
);

** Now suppose I want my Header component to constantly show across different pages
then I have to make the other pages as the children of the AppLayout component, as it contains the Header component in itself

import { createBrowserRouter,RouterProvider,Outlet } from 'react-router-dom';
const AppLayout =()=>{
  return(
    <div>
      <Header/>
      <Outlet/>
    </div>
  )
}
const appRouter=createBrowserRouter([
  {
    path:"/",
    element:<AppLayout/>,
    errorElement:<Error/>,
    children:[
      { path:"/", element:<Body/>, errorElement:<Error/> },
      { path:"/about", element:<About/>, errorElement:<Error/> },
      { path:"/contact", element:<Contact/>, errorElement:<Error/> }
    ]
 }  
])

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
 <RouterProvider route={appRouter}/>
);

now when path "/" is rendered the <Body/> is rendered in place of <Outlet/>
now when path "/about" is rendered the <About> is rendered in place of <Outlet/>
so the Header component remains intact and below that we add the outlet...

so whenever there is a change in the path, this Outlet will be filled with the children acc to the path

by clicking on 'About', it can move to the 'About' page using <a> anchor tag, which reloads the whole page(thus takes longer), which is bad practice, so we use the 'Link' component(it does not reload the whole page fully) from react-router-dom. It is a wrapper of the <a> tag, though which 'react-router-dom' keeps a track of this link.
import { Link } from 'react-router-dom';

** So whenever you are navigating to a different route, always use a Link component

Routing
----------
1. Client-Side Routing -  we are not making any sort of network call, rather we are doing changing of components as about, contact 
component already loaded in your local host. When we go to 'About us' page it loads the about component

2. Server Side Routing - When the local host makes a network call, it fetches the data for the About us page and reloads the page.

Dynamic Routing :
-----------------
where for each restaurant different page will be created
path: "/restaurant/:resId" so this resId  is dynamic, defined by a : in front

useParams from react-router-dom is used to find the id of the various dynamic routing.Params is a object with the unique id
useParams returns an object which contains the resId property(resId is the dynamic route part that you passed in the createBrowserRouter)
e.g-http://localhost:3000/restaurants/78511, useParams fetches the id :78511

which further is used for dynamic routing

Dynamic Routing:
------------------
Dynamic routing refers to the practice of generating routes dynamically based on certain parameters or data
e.g:<Route path="/user/:userId" element={<UserProfile />} /> userId keeps chaging according to individual ids.

** DO NOT USE TERNARY OPERATOR EVERYWHERE, AS YOU MAY RUN INTO UNWANTED ERRORS,
ONE SUCH SITUATION IS IF YOU ARE INITIALISING A STATE VARIABLE WITH NULL, AND LATER UPDATING IT WITH AN OBJECT WHICH IS FETCHED FROM SOME API
THEN IF YOU WANT TO ACCESS A PROPERTY OF THAT OBJECT, THE FOLLOWING ERROR MAY SHOW:-
TypeError: Cannot destructure property 'name' of '(intermediate value)' as it is undefined.
AS THE REQUIRED PROPERTY CANNOT BE EXTRACTED INITIALLY WHEN THE VARIABLE IS NULL
E.G.-

const [resInfo, setResInfo] = useState(null);

useEffect(() => {
    fetchMenu();
  }, []);

const fetchMenu = async () => {
    const data = await fetch(
      MENU_API + resId + "&catalog_qa=undefined&submitAction=ENTER"
    );
    const json = await data.json();
    console.log(json);
    setResInfo(json.data);
 };

const { name, cuisines, costForTwoMessage } =
    resInfo?.cards[0]?.card?.card?.info;

  const { itemCards } =
    resInfo?.cards[2]?.groupedCard?.cardGroupMap?.REGULAR?.cards[1]?.card?.card;
  console.log(itemCards);

  return resInfo === null ? (
    <Shimmer />
  ) : (
    <div className="menu">
      <h1>{name}</h1>
      <h2>{cuisines.join(", ")}</h2>
      <h3>{costForTwoMessage}</h3>
      <ul>
        {itemCards.map((item) => (
          <li key={item.card.info.id}>
            {item.card.info.name} - Rs.{item.card.info.price / 100}
          </li>
        ))}
      </ul>
    </div>
  );
};

export default RestaurantMenu;

INSTEAD YOU MUST DECLARE THE ALTERNATE CONDITION SEPARATELY IN A IF CONDITION:-

if (resInfo === null) {
    return <Shimmer />;           // SHOW THIS BEFORE DESTRUCTURING THE OBJECT, SO THAT DESTRUCTURING IS ONLY DONE WHEN THE OBJECT IS NOT NULL
  }
const { name, cuisines, costForTwoMessage } =
    resInfo?.cards[0]?.card?.card?.info;

  const { itemCards } =
    resInfo?.cards[2]?.groupedCard?.cardGroupMap?.REGULAR?.cards[1]?.card?.card;
  console.log(itemCards);

  return (
    <div className="menu">
      <h1>{name}</h1>
      <h2>{cuisines.join(", ")}</h2>
      <h3>{costForTwoMessage}</h3>
      <ul>
        {itemCards.map((item) => (
          <li key={item.card.info.id}>
            {item.card.info.name} - Rs.{item.card.info.price / 100}
          </li>
        ))}
      </ul>
    </div>
  );
};

** ANOTHER IMPORTANT ERROR WHILE FETCHING DATA FROM SOME EXTERNAL API IS:-
TypeError: Cannot read properties of undefined (reading 'length')
THIS OCCURS WHEN YOU WANT TO RENDER A LIST OF ELEMENTS(OBJECTS), BUT THE VARIABLE IN WHICH YOU WANT TO ASSIGN THE LIST,
HAS BEEN ASSIGNED SOME OTHER OBJECT INSTEAD OF A LIST, THUS SHOWING THIS ERROR
BECAUSE A LIST ALWAYS HAS A LENGTH PROPERTY

--------------------------------------------------------------EPISODE 8------------------------------------------------------------------------

CLASS BASED Component
-------------------------

 <UserClass name={"Ritushree Das"} location ={"Address"}/>
 All the props you have passed will bind into a single object ...

import React from "react";                       // React.Component class is given to us by React
import "./User.css";
class UserClass extends React.Component{         // this 'extends React.Component will let React know that this is a class-based component
    constructor(props){                          // in class-based components, the constructor receives the props
        super(props);                            // and then the obj will be passed to the Component
    }

    render(){                                   // this render() method will return a piece of JSX which will be displayed onto our UI 
        return <div className="User-card">
            <div>NAME :{this.props.name}</div>
            <div>Location:{this.props.location}</div>
            <div>Contact Us:@ritz.das</div>
        </div>
    }
}

export default UserClass;

** In functional component, the arrow function returns a piece of JSX, in class-based components, the render() method returns a piece of JSX

Why do we need to write super(props) in class-based components?
---------------------------------------------------------------
In React, you need to write super(props) in the constructor of a child component to call the constructor of the parent component. This is necessary because React uses a class hierarchy to render components, and each child component inherits the properties and methods of its parent component. By calling super(props), the child component is able to access the properties and methods of its parent component.
If you do not write super(props) in the constructor of a child component, React will throw an error. This is because React needs to be able to access the properties and methods of the parent component in order to render the child component.
We might require props inside the child component constructor with this keyword. super() function calls the constructor of the parent class. Using super constructor with props arguments basically allows accessing this.   // use of 'this' keyword


class UserClass extends React.Component {
  constructor(props) {             // constructor is always called at first, whenever an instance of that class is created, thus it is preferred to declare the state variables inside it
    super(props);
    this.state = {                     // this.state is a large object that contains all the state variables (in functional components, even though we declare multiple state variables 
      count: 0,                           separately, but behind the scenes, React manages a large object for all the state variables like this)
      count2: 2                        // creating state variable is always inside the constructor
    }
  }

  render() {  
    const {name} = this.props;           // destructuring this.props
    const {count, count2} = this.state;  // destructuring this.state
    return (
      <div className="user-card">
        <h1>Count : {count}</h1>
        <h1>Count2 : {this.state.count2}</h1>
        <h1>Name : {name}</h1>
        <h2>Location : Kolkata</h2>
        <h3>Contact : arpandesp@gmail.com</h3>
      </div>
    );
  }
}

** NEVER UPDATE STATE VARIABLES IN CLASS-BASED COMPONENTS DIRECTLY
use this.setState() for this purpose

    <button
          onClick={() => {
            this.setState({                    // we pass an object inside this.setState(), which contains the updated value of the state variables
              count: this.state.count + 1,     // you can also update some other state variables inside this this.setState(), if necessary(updating simultaneously)
            }); 
          }}
        >
          Increase count
    </button>


---now when the About component is mounted/loaded in the webpage it then goes through the JSX line by line and when it sees that the UserClass Component, it then starts loading the UserClass component, and an instance of the component is created, which calls its constructor at first, and then the render() method.

LifeCycle of Hierarchical Class-based Component(both parent & child are Class-based Component)
----------------------------------------------------------------------------------------------
Parent Constructor-->Parent Render-->Child Constructor-->Child Render

componentDidMount(){           // this componentDidMount() method executes only when the component inside which it is declared, actually mounts on our webpage, i.e., 
  console.log("HII MOUNT");       // constructor --> render() --> componentDidMount()
}

Parent Constructor-->Parent Render-->Child Constructor-->Child Render-->Child Component did Mount-->Parent Component did Mount
//once the child component is mounted successfully then the parent component is finished mounting

** An important use case of componentDidMount() is to make API calls because we don't want to wait for the result of the API call, thus we render our class component quickly at first, then receive data from the API call and then re-render it

** Because of this same reason, we make API calls in functional components using useEffect(), which is called once the component has been loaded

now first when UserClass is loaded the sequence of loading follows:
1.Constructor
2.render
3.componentDidMount
--------------------------------------------
now suppose if About.js is a class-based component --->calling--->UserClass which is also a class Based component
Calling sequence---
1.Parent Constructor
2.Parent render
    1.UserClass is called (Child)
          1.child constructor
          2.child render
          3.child componentDidMount
3.Parent componentDidMount
------------------------------------------------

** FOR MULTIPLE CHILDREN OF PARENT CLASS

class About extends React.Component {
  constructor(props) {
    super(props);
    console.log("Parent Constructor");
  }
  componentDidMount() {
    console.log("Parent componentDidMount");
  }
  render(){
    console.log("Parent render");
    return (
      <div>
        <h1>About</h1>
        {/* <User name={"Arpan De USER"}/> */}
        <UserClass name={"Arpan De USERclass"}/>      //Child 1
        <UserClass name={"Another Guy USERclass"}/>   //Child 2
      </div>
    );
  }
}

Flow will be->
--------------
Parent Constructor
Parent render
    Child 1 Constructor
    Child 1 render
    Child 2 Constructor
    Child 2 render
    Child 1 componentDidMount
    Child 2 componentDidMount
Parent componentDidMount

LIFECYCLE 
----------------
2 PHASES:
1. Render phase (is fast)
in the render phase -- first constructor is called then the render method

2. Commit phase (is slow) (bec updating the DOM is an expensive task)
after all the updation in the DOM through the render phase then DidMount is called
so DidMount is the place where API is called. 
DOM is also updated in a single batch, after calculating the DIFF of all the elements in the virtual DOM

** REACT DOES CODE OPTIMIZATION BY BATCHING THE RENDER PHASE OF ALL THE CHILD COMPONENTS TOGETHER, AND THEN THE COMMIT PHASE
THUS IF A PARENT COMPONENT HAS MULTIPLE CHILD CONSTRUCTOR, ONLY THE RENDER PHASE (CALLING CONSTRUCTOR + CALLING RENDER) OF ALL ITS CHILDREN ARE COMPLETED FIRST

-------------MOUNTING CYCLE---------------
-Constructor(dummy data)
-Render (dummy data)
      <HTML dummy>
-componentDidMount
      <API CALL>
      <this.setState>--->state variable updated

----------UPDATING CYCLE------------
-Render(API data)
     <HTML (new API data)/>
-componentDidUpdate

--------------UNMOUNTING CYCLE---------
-componentWillUnmount
       this is called just before unmounting the component
       this will be called when we go to another page

** In functional components, after fetching API data, we change the state variables inside fetchData() only, similarly, in class-based components, after fetching API data, you need to change state variables using this.setState() inside componentDidMount() only

----------------------------------------------------EPISODE 9---------------------------------------------------------------------------------

** We must follow the Single Responsibility Principle(i.e., a component should have only one major responsibility) while building different components for our application, which brings modularity to our code and makes our code:-
    -Reusable
    -Maintainable
    -Testable

CUSTOM HOOKS
----------------
A user created Hook which is a utility function.
Naming convention: write the component starting with "use".

** In order to create a custom hook, you need to determine the contract, i.e., you need to properly specify what is the input for that hook(e.g. some data that comes from the caller function), and what is its output

Now to move offline go to inspect-->network-->then in drop down no throttling, select offline

** Suppose your app has 1000 components, you may load 1000 components, or you may bundle all of them into 1 JS file. 
In the first case, there will be too many function calls, in the second case, the size of the JS file will become very large. Thus both are not viable solutions. 
In order to solve this problem, we use the concept of Chunking or Code Splitting, which is basically dividing our application into smaller logical chunks.

----DYNAMIC BUNDLING--------
Dynamic bundling or chunking, often referred to as code splitting, is a technique used in web development to improve the performance
 and loading time of a web application. The idea is to split the JavaScript code into smaller "chunks" or "bundles" and load them on-demand, 
 instead of loading the entire JavaScript code at once. This is particularly useful for large-scale applications where the initial download size
  can be substantial.

  -----LAZY LOADING/(ON-Demand Loading or Dynamic Import)----------
  Lazy loading is a technique used in web development to defer the loading of certain assets (such as images, scripts, or stylesheets) until they are
   actually needed.
   when our app loads the grocery does not load, when we go to the grocery at that point it loads
   -----lazy() is a named export given by react
    -It takes a callback function calling the import() function and inside the import function the path of the component that needs to be loaded on demand is given
    so making grocery have its own bundle and the main bundle is different(app.js)

   ----Suspense------
    <Suspense fallback={<Shimmer />}><Grocery /></Suspense>
    Suspense is written as without it an error occurs. As when our app tries to load the Grocery component instantly, it cannot because it takes a few milliseconds to load the component, so we need to write a Suspense fallback, which is a named import from react
    that shows what will be loaded in the absence of Grocery component(that intermediate state of loading the component)


------------------------------------------------------EPISODE 10---------------------------------------------------------------------------------

Types of writing CSS--
1. Normal CSS    2. SASS/SCSS    3. Styled component    4. Tailwind CSS

---------LIB-----------------------
MAterialUI library (in react)
ChakraUI 
Bootstrap
ant design
----------------------------------

Tailwind CSS works with various frameworks, normal HTML..and so on
Tailwind CSS uses postcss behind the scenes. (Postcss is a tool for transforming CSS with JavaScript)

npx tailwindcss init -----it will create a taiwind.config.js
content: [
    "./src/*/.{js,jsx,ts,tsx}",
  ],
  telling our project that tailwind can be used in js file,jsx file, and so on

.postcssrc is the configuration file for postcss
taiwind.config.js is the configuration file for tailwindcss

Parcel needs this .postcssrc file to understand what is written in tailwind 

in index.css file, you need to write
@tailwind base;
@tailwind components;
@tailwind utilities;
these 3 lines to use tailwind in our CSS file

TailwindCSS automatically gives you class names for all the CSS that you need to write

In TailwindCSS, everything happens related to the class name

Dynamic classes in tailwind w-[200px]

  Disadvantages of tailwindcss-
  1. it makes the code look ugly
  2. it becomes messy to handle 

  Advantages--
  1. It is very light-weight, if we write 10 times m-4 it just takes it as one m-4 class
  2. It loads only those CSS that are required in our webpage, suppose a shadow class is mentioned in the code, but it is not used, then it will not load that shadow class


  -------------------------------------------------EPISODE 11---------------------------------------------------------------------------------

  HIGHER ORDER COMPONENT--a function that takes a component and returns a component

  It is basically used for enhancement. Suppose in the body component we want some cards to be labeled as 'promoted' by our app.
  NOTE: as promoted not in the API so making every restaurantCard id which is divisible by 5 as promoted... 

const withPopularLabel = (RestaurantCard) => {  // RestaurantCard is given as input to this HOC
  return (props) => {
    return (
      <div>
        <label className=" absolute bg-black p-2 m-2 text-white rounded-lg">Popular</label>
        <RestaurantCard {...props}/>  //We are writing ...props, because we want to pass everything that we receive, without modifying the data       
      </div>
    );
  };
};

You can access a HOC in the following way:-
 const RestaurantCardPopular = withPopularLabel(RestaurantCard);

  ----REACT APPLICATION has 2 layers-----
  1. UI LAYER
  2. DATA LAYER

  UI LAYER GETS POWERED BY DATA LAYER
  (The data layer consists of props, state variables, local variables ...etc) (/Major thing is to handle the data layer/)

  FILTER----out all the item categories and enhance the individual restaurant menu
  @ is not supported so we need to write ["@type"]
  The expandable dropdown format of the categories (UI) is called ---"Accordion"

  ----REACT DEVELOPER TOOLS-----
  features----
  1. Components
        it shows the component hierarchy of the system, basically the virtual DOM
  2. PROFILER
        it mainly records your actions and after stopping recording it shows the components invoked
  
  -----------CONTROLLED AND UNCONTROLLED Components--------LIFTING THE STATE/DATA-------------
    RestaurantMenu is controlling the Restaurant Category for now, suppose there are 4 categories, and suppose if we expand the recommended category all other categories must collapse.

    This is called 'lifting the data/state up' as the control is in the hands of the parent and not of the child

    UNCONTROLLED---when the restaurant category controls their own state individually

    CONTROLLED COMPONENT FULL EXPLANATION 
    -------------------------------------------
    RestaurantMenu.js(PARENT)
    -----------------------------

    const [showIndex,setShowIndex]=useState(0);
     {categories.map((category,index)=>(
                <RestaurantCategory key={category?.card?.card.title} 
                data={category?.card?.card} 
                showItems={index===showIndex?true:false}      //we are setting which category items to be showed 
                setShowIndex={()=>setShowIndex(index)}/>      //We are passing the setShowIndex function to the children because the children cannot directly access the state variable of 
     ))}                                                        the parent 
    By default, category 0 is always shown with their items as showIndex initially 0.
    showIndex controls which category to be shown, if category 0 is opened automatically other categories get closed 
    on clicking other categories the setShowIndex function is called which returns from the children RestaurantCategory and sets the showIndex with its index value then
    showItems gets equal to the actual index value and the index of the category  clicked which changes that particularly
    category to true which means that one category will show its items and others will not show their items

    RestaurantCategory.js (CHILD)
    -------------------------------------

    const RestaurantCategory=({data,showItems,setShowIndex})=>{
        const handleClick=()=>{
          setShowIndex();          // whenever we click on an item, it will call this setShowIndex(index) from setShowIndex={()=>setShowIndex(index)} in its parent
      }
      return (
        <div>
            <div className="flex justify-between cursor-pointer "onClick={handleClick}>
            {showItems&&<ItemList items={data.itemCards}/>}
        </div>
    )
 }

 Basically what happens on click of a category is, it calls the setShowIndex() function which modifies the parent RestaurantMenu 

 LIFTING THE STATE UP ---PARENT CONTROLLING ITS CHILDREN

----------PROPS DRILLING--------------
 IN REACT, passing data through components is a tough job. So data flow is one-way. parent->children->children
 root->children->children->ans so on
 Now suppose I want to pass the data to the last children so we need to move the data between its intermediate parents.

 In that case, we use React Context so that we can pass the data directly.
 Because Context is an approach like a global data is placed and anyone can access it when needed. 
 eg-logged in user info, or the theme (light or dark theme)

 createContext()(which is a utility function) is used for making global data. 
import { createContext } from "react";
 const UserContext = createContext({
    loggrdInUser: "Default User",          // the object that we pass inside createContext() is like a global object or the context
 });
export default UserContext;

 useContext() is another important hook that is used for accessing the global data.
 const data = useContext(UserContext);

 In class-based components -> You don't have hooks, thus use it in this way:-
--------------------------
 <UserContext.Consumer>
 {(data)=>console.log(data)}      // Inside Consumer component, you need to write a piece of JSX that takes a callback function which gets access to that global data/context
 </UserContext.Consumer>

 or more destructuring---
 <UserContext.Consumer>
 {({loggedInUser})=><h1>(loggedInUser)<h1/>}
 </UserContext.Consumer>

 ------To modify the data and make the data accessible to all the other components we use UserContext.Provider ------

  const [userName,setUserName]=useState();
  useEffect=(()=>{
   //API CALL;
   const data={
    name="Akshay Saini"
   },
   setUserName(data.name);
  },[])

 <UserContext.Provider value={{loggedInUser:userName}}>
     <Header/>
     <Outlet/>
 </UserContext.Provider>

Header component and other components inside the Provider can access the modified value;
NOTE: it is very powerful as we can apply provider to some components or the whole app.
The scope of a region in your app, where you want to change the value of the global data, should be inside the Provider component

** You can also do nesting of Provider component
 <UserContext.Provider value={{loggedInUser:userName}}>
    <UserContext.Provider value="Arpan De">
         <Header/>
    </UserContext.Provider>
      <Outlet/>
 </UserContext.Provider>
Here, the Outlet component will get updated by the value of userName, and the Header component will get updated by the value of "Arpan De"

------------------------------------------------------------------------------
const [userName,setUserName]=useState();
<UserContext.Provider value={{ loggedInUser:userName,setUserName }}>   //we can pass setUserName so that we can update the userName from other components also
    <Header />
    <Outlet />
</UserContext.Provider>

Body.js
--------
const {loggedInUser,setUserName} = useContext(UserContext);
<input className='border border-black p-2 ' value={loggedInUser} onChange={(e)=>setUserName(e.target.value)}></input>
so now on every change of keystroke the loggedInUser changes.

-----------------------------------------------------------------------
useContext and Redux Toolkit Different
===============================================
redux is more scalable 
in useContext, we need to make different contexts for different types of data.

State Management:

useContext:
------------
Primarily designed for managing local component state or sharing state between a few closely related components.
State is managed within the component or a few related components.

Redux: (It is a State Management Library, not inside React)
------
Designed for managing a global state that can be accessed by any component in the application.
State is stored centrally in a Redux store, and components can subscribe to changes in the state.


-------------------------------------------------------------------EPISODE 12------------------------------------------------------------------
------------Searching Menchanism in search Bar----------------------
 
Fetching Relevant Suggestions on Keystroke

Debouncing: Implement debouncing to handle rapid keystrokes. Debouncing delays the function execution until after a certain amount of time has passed since the last keystroke, improving performance and preventing excessive API calls.

Search Algorithm: Match the current input with stored search history to find and display relevant suggestions.


-------------------REDUX----------------------------------------
--------Works in the Data Layer-----------------------
NOTE: REDUX AND REACT ARE DIFFERENT Libraries.

REDUX is a lib used for managing state. (Another lib is zustand)
Using Redux makes an Application easier for debugging

                   TWO LIB
                      |
        ----------------------------------
        |                                |
    React-Redux                    Redux-Toolkit (packages are intended to be  the standard way of writing redux logic)
(Bridges the gap b/w               (Also called RTK)
React & Redux lib)

VANILLA REDUX IS THE OLDER REDUX(WHICH SAYS DON'T MUTATE STATE)

--------REDUX STORE---------(A big JS object which is kept in a central global place)
We can keep all the data in our redux store but slice-wise. 
Slices can be small portions(logical partitions) of a redux store like:- (one is cart data slice),(other is logged-in user slice)

** But you cannot directly write data/modify your slices in the Redux store
You have to do it this way:-
CART button (Click) ----->Dispatches an action---->calls a function---->which internally modifies the cart(slice)(updates the slice)
                                                              ^
                                                              |
                 ----------------------------------------------
                 |
What is this function?
this function is known as a reducer function.

Now how to read data from the cart slice in the redux store?
--------->from cart slice---->|Selector|----------->that reads the data from the store------->modifies the cart component on your app
    using a |SELECTOR|------>(this phenomenon is called subscribing to the store) for e.g.-(our header component have subscribed the store) 
** (The header component will reflect the changes as soon as the cart slice has been updated)

Installation:->
npm i @reduxjs/toolkit 
npm i react-redux

Steps:-
--------
1) Build a store                          ----------------configureStore() --import { configureStore } from "@reduxjs/toolkit";
2) Connect the store to our app           ----------------<Provider store={}> --import { Provider } from "react-redux";
   (Provide the store to our app)             (We pass the store as a props to it)
   // Just like Context.Provider, wrap everything(all the scope of the region) inside the Provider to which you want to provide the store
3) Cart (cartSlice)                       ----------------createSlice({}) --import { createSlice } from "@reduxjs/toolkit";
   // It takes a configuration to create a slice
        First config -> name
        Second config -> initialState (tells about the initial state of that slice)
        Third config -> reducers (here we write the reducer functions corresponding to their actions)
    reducers: {
        addItem: (state, action) => {},  // this addItem is the action, and corresponding to it is the reducer function, 
    }                                       which takes two parameters- 1. state(the state of our store), 2. action(what it will perform) (sometimes action is not needed)
    ** Also the store, i.e., appStore, has its own reducer, whose job is to combine the reducers of all its slices
4) dispatch(Action)                       ----------------reducers, done by dispatch() --import { useDispatch } from "react-redux";
5) Subscribe to the store(using Selector) ----------------is nothing but a react hook, useSelector() --import { useSelector } from "react-redux";
    // const cartItems = useSelector((store) => store.cart.items);
    // useSelector gives you access to the store, you need to mention which part of the store you want to access

const handleItems=(items)=>{
    // dispatch an action to add an item
    dispatch(addItem("pizza"));           // this "pizza" is the action.payload
}
// Whatever you pass inside the action is given as a payload
// Behind the scenes, redux creates an object   -   {payload: "pizza"}  

onClick={()=>handleItems(items)}//correct way (passing a callback function)
onClick={handleItems(items)}//NOT correct as we do not want to immediately call a function but call it when the add button is clicked (this is calling a func right away)

-----------------------------------
1. const cartItems=useSelector((store)=>store.cart.items);//from the store we are only subscribing to a slice
or
2. const store=useSelector((store)=>store);    // subscribe to the whole store
   const cartItems=store.cart.items;           // then subscribing to a slice

note: 2nd way is not an effective one as we do not need any sort of update for other slices rather than the cartSlice
// Whenever you are using a selector, make sure you are subscribing to the right portion of the store
-----------------------------------------

in appStore, the reducers from all its slices are kept in 
reducer:{               // one main reducer for the whole app containing multiple small reducers
  cart:cartReducer
}

in cartSlice 
the reducer functions are kept in
reducers:{
  //mutating state directly(mandatory), return is not required, does this with the help of 'Immer' library (a tiny package that allows you to work with immutable state easily)
  addItem:(state, action)=>{   //state is a local var having the value of the current state of that slice
      state=["Akshay"];       //it won't work like this, because this is not mutating the state, just adding another reference to the state
      state.items.push(action.payload);     //mutating the state
  }
}

** Suppose at a particular instance, the current state is state=["pizza"];, then if we do state=[];, then the state(which is a local variable) will be assigned to a new empty list, without modifying the original list/state, which would still contain "pizza", i.e., ["pizza"] would still be as it is

** In Vanilla(older) redux => DON'T MUTATE STATE, returning was mandatory
    const newState = [...state];
    newState.items.push(action.payload);
    return newState;
** But behind the scenes, Redux does everything in the older way

reducers:{
  clearCart:(state,action)=>{ 
    //in redux we cannot simply console log(since it creates a proxy object)--we need to use current
    state=[];
    console.log(current(state));                                   // import { current } from "@reduxjs/toolkit";
    //RTK says either update/mutate the existing state or return the new state
      state.items.length===0;
  -------OR----------
      return {items:[]};  // whatever you return from the reducer, will replace whatever is present in the original state
  }    // since original state was {items:["pizza"]}
}

-----------------------------------------------------------EPISODE 13-------------------------------------------------------------------------
TESTING
------------

Types of testing (Developers can do):
1.Manual Testing --which mainly we focus whether the functionality is working fine or not according to the code.
(we particularly see the functionality of the specific type but not the whole application)

(So to check the whole application where a single line of code causes error for other functionalities or not)
2.writing Test cases---that automatically tests our whole application.

    -Unit Testing                ----(only one specific component)
    -Integration testing              -----------(test the flow of data and control between diff components that will lead to some result)
    -End to end testing(e2e testing)    ---------------(User lands on the page...and actions performed --to user leaving the page)

   NOTE   ::::: Developers are responsible for unit testing and Integration testing

---use React-testing library to write test cases in React
(React testing lib is build on DOM testing LIB)
React testing lib takes "jest" delightful js framework 

-------INSTALLING PROCEDURE--------
install--1.react-testing lib  2.jest
now install jest working with Babel
if we config babel and parcel has its diff babel config behind the scenes so that will conflict ....
so we need to go to parcel then js then using other tools and write parcel.rc  basically to disable default babel transpilation
then perforn npx jest --init
install jsdom library

-----------------------------------------------------------------EPISODE 14---------------------------------------------------------------------------------------

** npx create-react-app uses Webpack as a bundler(just like Parcel)
    It gives you testing support. It installs react testing libraries by itself.

** AN IMPORTANT ERROR
Uncaught runtime errors:
×
ERROR
You cannot render a <Router> inside another <Router>. You should never have more than one in your app.
THIS ERROR WILL OCCUR IF YOU PUT A ROUTER BODY INSIDE ITSELF, E.G.-
const Body = () => {
  const appRouter = createBrowserRouter([
    { path: "/", element: <Body /> },              // this Body is inside itself
    { path: "/browse", element: <Browse /> },
  ]);

  return (
    <div>
      <RouterProvider router={appRouter} />
    </div>
  );
};

NOTE:
-----------------------------------
LIB -FORMIK for validation of forms
-----------------------------------

const isEmailValid = /^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$/.test(email);  // This is how you can whether the email is valid or not based on the regex, text() returns boolean

** There are two ways to access value from input boxes
1. Using State variables and binding them to value
2. Using useRef() hook

IN FORM:
 <form onSubmit={(e)=>e.preventDefault} ............ /> // This is done to prevent auto-submitting of the form, due to the clicking of any button inside it
// If it is not done then it refreshes our page each time we click a button, so to prevent it we do e.preventDefault()

--------------------------USEREF --------------------------
To capture the email entered or password we can create individual state variables, and onChange the value of the state variable changes as we bind the value of the input with the state variable
Another way:  is to use the reference of the input value
------------
This is where the useRef() hook comes into the picture

const email = useRef(null);  // useRef() takes an initial value

<input ref={email} .............. />  // This ref property gives you information about the input box in the form of an object  

<button onClick={()=>console.log(email.current.value)}>

----FIREBASE AUTHENTICATION-------------

1. Create a project
2. Select Web and do all actions(npm i firebase - if you want firebase hosting) and write the code in firebase.js according to the instructions
3. Go to authentication and enable email/password (IMP:- IF CORS IS ON, IT WON'T WORK, FIRST SWITCH IT OFF, THEN SAVE IT)
4. Then go to firebase authentication in the documentation and go to Password authentication, then move to 'Create a password-based account' 
  -there is a statement of auth, i.e., const auth = getAuth(); - that should be written only once as it is used everywhere so write it in firebase.js, and export it from there
5. Write the logic for sign-in and sign-up
6. Make a redux store of user slice -----
    6.1. For authentication handling go to onAuthStateChanged of firebase authentication docs(in Manage Users)
         - onAuthStateChanged handles whenever there is an authentication state change(sign up/sign in/sign out) in the user details (thus we don't need to manage a user in the redux store)
7. Inside useEffect (because we want to render only once after a state change), write the logic of auth change, and in sign-in in addUser to the redux store(Body.js) and in sign out remove User from the redux store
8. Now in the header do a sign-out button and onClick an event occurs
- From Firebase docs go to password authentication and go to sign out logic and if sign out navigate to the Login page(Login.js)
9. To update the name of the user ...go to manage users and update the user profile if sign-up is done correctly.
and once update then navigate (Login.js)
10. useSelector to fetch the icon from the redux store and dispaly only if the user is not null
11. Bug---in signup the icon was not updating 
    -So made the dispatch addUser after the profile goth updated --- from auth.currentUser which consists the current user

** Just like in Parcel, where all the production-ready codes were kept in the 'dist' folder, in create-react-app, the production-ready codes were kept in the 'build' folder
-- What do you want to use as your public directory? build
-- Configure as a single-page app (rewrite all urls to /index.html)? No
-- Set up automatic builds and deploys with GitHub? No

IMPORTANT
---------
IF YOU DO firebase login YOU MAY FACE THE FOLLOWING ERROR:-
firebase : File C:\Users\User\AppData\Roaming\npm\firebase.ps1 cannot be loaded because running scripts is disabled on this 
system. For more information, see about_Execution_Policies at https:/go.microsoft.com/fwlink/?LinkID=somenumber.
TO SOLVE THIS, DO THE FOLLOWING:-
1) OPEN POWERSHELL AS ADMINISTRATOR
2) RUN Get-ExecutionPolicy - YOU WILL GET Restricted
3) RUN Set-ExecutionPolicy RemoteSigned YOU WILL GET 
Execution Policy Change
The execution policy helps protect you from scripts that you do not trust. Changing the execution policy might expose
you to the security risks described in the about_Execution_Policies help topic at
https:/go.microsoft.com/fwlink/?LinkID=yournumber. Do you want to change the execution policy?
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "N"): 
TYPE Y, AND HIT ENTER
4) RUN Get-ExecutionPolicy - YOU WILL GET RemoteSigned (ERROR SOLVED)

STEPS FOR DEPLOYMENT
--------------------
0. Install firebase CLI - 'npm install -g firebase-tools'
1. Firebase login - 'firebase login'
2. Initialize firebase - 'firebase init', then select Hosting
3. Deploy command - 'firebase deploy'

AN IMPORTANT ERROR
------------------
Uncaught runtime errors:
×
ERROR
useNavigate() may be used only in the context of a <Router> component.
THIS ERROR WILL SHOW UP IF YOU TRY TO USE THE useNavigate() HOOK OUTSIDE YOUR <Router> COMPONENT
FOR E.G.- IN Body.js
const Body = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();              //This is outside RouterProvider, so it won't work, it can only work inside RouterProvider, i.e. child components of Body.js
  const appRouter = createBrowserRouter([
    { path: "/", element: <Login /> },
    { path: "/browse", element: <Browse /> },
  ]);
  useEffect(() => {
    onAuthStateChanged(auth, (user) => {   
      if (user) { navigate(...); } 
      else { navigate(...); }
    });
  }, []);
  return (
    <div>
      <RouterProvider router={appRouter} />
    </div>
  );
};
POSSIBLE SOLUTIONS ARE->
1) Use window.location.href to navigate
2) Move your routing i.e., appRouter out of your Body.js, and put in at the App level, i.e. App.js or index.js
3) Don't use navigate() here, but use it in some other place, that is within RouterProvider, because navigate() will only work in the routes of the appRouter(not outside them), as appRouter is provided to the RouterProvider
thus navigate() will only work in Login, children of Login, Browse, children of Browse
4) Put the whole useEffect() in some global central place, which is there in our whole app but that should be also inside our RouterProvider (like Header in this case)

------------------------------------------------------------EPISODE 15 & 16-----------------------------------------------------------------------------

FIXING BUG-
--------------
When we are in the "/" route i.e., on the homepage or login page then if we change the URL to "/browse" we will navigate to the browse page, even if we are not signed in, which is not right, and if, after sign-in, the user wants to go the login page we should not allow it (as the user is signed-in)

SOLVING: Replacing the onAuthStateChanged to the header component as we know header is present everywhere so useEffect works fine in that. 
Every time there is a change or reload, the Header is everywhere, so once we sign in /sign up it redirects us to the browse page and after signing out it redirects us to the login page
// Thus no unauthorized access to other pages

// When the component unmounts we do not want any sort of change
useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      if (user) {
        navigate("/browse"); 
      } else {
        navigate("/");
      }
    });
    // Unsubscribe when the component unmounts
    return () => unsubscribe();
  }, []);

TMDB --movie database
  -Login
   -Edit profile
   -API (left side)   find ur API key and API access token

go to movie list -now playing---on demo code, const options is mandatory to pass every time so keep it in constants.

Why does everything(API calls) happen twice? (only happens in Dev mode, won't happen in build)
Because our app is wrapped inside React.StrictMode, React does extra rendering to check the consistency of your data

browse page structure
---------------------
-MAIN CONTAINER
  -VideoBackground
  -Video title
-SECONDARY CONTAINER
 -MovieList *n
 -cards *n

 NOTE: there can be multiple trailers of one movie or no trailer if no trailer take the first video of that particular movie and if trailer exists take trailer

 --MOVIELIST: POPULAR
      -MOVIECARDS *N
 ---MOVIELIST: NOW playing
  |
  |
  |
  |
  (N)

  Do tmdb image URL to get the CDN URL

 ** {movies?.map((movie) => (
         <MovieCard key={movie.id} poster={movie} />
    ))}
    //optional chaining is extremely important, as initially, the value of movies was null, so .map property cannot execute, hence will throw an error
ERROR->
Unexpected Application Error!
Cannot read properties of null (reading 'map')
TypeError: Cannot read properties of null (reading 'map')

  OPENAI:platform.openai
  npm open ai---helper func to make api call directly
  then after using console(gptresult.choices)

  then go to tmdn search movies....and fetch the search api to fetch the individual details of the suggested movies'

  .env  file all the secret keys are kept ---with REACT_APP at the starting

  when we are clicking on gpt search or homepage we are making api call where our movies are already had the trailer vid
  so we use memoization , to prevent refetching

  const nowPlayingMovies=useSelector(store=>store.movies.nowPlayingMovies);
  useEffect(()=>{

        //memoisation   
        !nowPlayingMovies && getNowPlayingMovies();
    },[])

    NOTE: we can tell user to give their open ai key and the users can use it instead of using our key---(implement in ur upcomming projects)
    ---------Responsiveness-----
  default :mobile(small screen )
    sm: greater than small screen  (tab)
    md :greater thann meduim screen(desktop)

 -------------------------------------------------BONUS 1 && 2----------------------------------------------------------------------------------
    Machine Coding Interview Round
    ------------------------------------

    1.Requirements (on the topic: what features to be added)
    2.Tech Stack(UI layer:Tailwind css  DataLayer:React,react-router-dom,Redux and so on---)
    3.Planning of the structure of our app(visualisation)

    ReportWebVitals
    ------------------
    Web Vitals are a set of useful metrics that aim to capture the user experience of a web page. In Create React App, a third-party library is used
     to measure these metrics (web-vitals). 

    strictmode--React's Strict Mode is a development mode only feature for highlighting potential problems in an application. It helps to identify unsafe 
    lifecycles, legacy API usage, and a number of other features.


    GRID IN CSS- the whole grid is basically divided into 12 grid section 

    AXIOS---fetching---for json handling

NOTE:::::::::::
  IN UTUBE : SEARch apis then search api key utube auth
    IN GCP while making api key---(GO to lib and enable the utube v3 api) to access the token ( so that it works)

    Header remains same:In BOdy only the watchPage,Maincontainer Changes so keet it in Children 
    and do <Outlet/> after SIdebar in the Body.js


    const [searchParams] = useSearchParams(); is given if not using normal params---/watch?v=

    it is native browser search params;;;
    we do v.get()   //as v was the name of the id

    Debouncing---
    suppose with every key stroke the api is getting an api call 

    key-i 
    render the component 
    call the useEffect
    start the timer -make an api call after 200ms

    key-ip
    destroy the component (useEffect return Method)
    re-render the component 
    call the useEffect
    start the timer -make an api call after 200ms


    //--in searching if we search the same keyword again it will not make an API call
    //we use redux to do it.


    ----------------------------------------------BONUS 3----------------------------------------------------------------------------------------
    Live Chat ---Challenges face::---
    1.Get Live Data (Data Layer )
    2.UI Layer update (UI Layer)

    Live Chat 
    --Each comment is a div but when we comment comes it appends the new div ...
    --this may lead to heavy weight of the HTML--
    we need to handle the complications as well as the the UI experience

    Two ways we can update the Live Data---
    1.web socket (It creates an handshake between the UI and Server)(Bi-directional Live data)(No interval)
        They are Heavy we do not need it.(eg-trading,websockets)
    2.Long polling /(API polling) Ui requests  the Server and server send the data to the client. After the some interval it checks whether new data
         has arrived or not
          EG: Gmail,Utube live chat

  UI experience---
  that if after sometime it starts deletes the the live comments..it holds only a upto a certain length

  //Infinte scroll Working::::::
  Like OnScroll event -->we are making an api call an updating the redux store by appending the videos at the end.
It is the final line 1619
