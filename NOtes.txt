-------------------------------------------------EPISODE 1--------------------------------------------------------------------------------
CDN LINKS FOR REACT:
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script type="module" src="./app.js"></script>

CDN :    "CDN" stands for Content Delivery Network. CDNs are networks of distributed servers
that work together to deliver web content, such as images, stylesheets, JavaScript files, and other assets

crossorigin: 
1. Browser security rule preventing requests to different domains.
2. to request the browser to fetch such resources 
with CORS (Cross-Origin Resource Sharing) headers. (Mechanism allowing servers to specify resource access permissions.)

NOTE: The order of the links should be maintained
-----
LINK 1: USE : Suitable for development environments with useful warnings and error messages for developers. 
It includes extra checks and debugging information.

LINK2 : USE :  Used in development environments along with React. It includes additional functionality related to 
rendering React components in the DOM.



-------------------------------------------------EPISODE 2--------------------------------------------------------------------------------

//React.createElement=>Object=>HTML

npm install -D parcel  //-D is a flag for dev dependency
npm -package  
dependency- The dependencies object specifies the packages that you need to run your code.


dependency---1.dev dependency (in development phase)   2. normal dependency (in development phase + production phase)
^-caret (automatic minor upgrades e.g. version 2.8.3 to 2.8.4)
~-tilde (for major upgrades e.g. 2.8.3 to 3.0.0)


package.json - mainly the version of packages that the npm is handling (also the changes from minor to major) (configuration for our npm)
package-lock.json - keeps track of the exact version of all the dependencies
node modules-data base or collection of dependencies


npm install parcel (beast)
we need parcel-->parcel depends on its other dependencies-->this nesting of dependencies is known as a transitive dependency


.gitignore---blocks all those files mentioned in it from uploading into the git repo (contains all the files that I don't want to push into GitHub)

We should not put the node modules into the production (no need to upload them)
that is why package.json and package-lock.json are necessary to be uploaded (because they maintain a note of all those dependencies our project needs), as they help in regenerating the required node modules for our project
we just need to do "npm install" and it will recreate all those node modules for us

npx parcel indexReact.html --will provide a server for our app
npx - executing a package


cdn links are not a preferred way to bring React and ReactDOM into our project - as it is a network-costly operation and React version control becomes difficult
"npm install" is the same as "npm i"

Features of Parcel--
-creates a Dev Build for you
-creates a Local server for you
-does HMR = Hot Module Replacement (exchanges, adds, or removes modules while an application is running, without a full reload)
-this HMR is done by File Watching Algorithm - written in C++
-does Caching (in .parcel-cache folder)- which provides Faster Builds 
-does Image optimization
-does Minification which is essential for production build
-does Bundling
-does Compressing
-does Consistent Hashing
-does Code Splitting for you
-gives Differential Bundling to our app (so that our app runs smoothly on older browser versions as well)
-gives Diagnostics of our app
-provides good error handling (better error suggestions)
-HTTPS
-does Tree Shaking Algorithm -  analyze the import, and export of each module, and remove everything that isn't used
-different dev and prod bundles

"npx parcel indexReact.html"
when you write this, it generates a development build of your project and hosts it into port:1234 (which comes from the "dist" folder)

when we refresh the page or save files, it uses the ".parcel-cache" and "dist" folders to update the webpage using HMR

The "dist" and the ".parcel-cache" folders can be automatically generated on each build, thus they are not required to be put into GitHub

you can create a production build in the following way-
"npx parcel build indexReact.html"
//this will build a bundle(or minify), and it will put all those files into a new folder i.e. "dist" folder (that are production-ready files for the app)
//note: before writing this, from package.json delete the "main" key (else there may be a conflict)

** Local project does not directly connect with the Server
** Local pushes its code into the git (like package.json & package-lock.json is pushed and not the node-modules)
** Server then fetches the code from the git (fetches the package.json & package-lock.json to create the node-modules)
** The Server then hosts the code to the end-user
** The copy of node-modules in the Local is different from the copy of node-modules in the Server

inside package.json we configure browserslist(this tells about all the systems our app is compatible with):-
browserslist:[
    "last 2 Chrome versions",
    "last 2 Firefox versions"
] //the last 2 versions of Chrome and Firefox will definitely support our app
* "last 2 versions" - this will cover the last 2 versions of all the systems

-------------------------------------------------EPISODE 3--------------------------------------------------------------------------------

we can configure the scripts in the package.json:-
scripts are industry standards to shorten repetitive codes for starting/building our project
"scripts": {
    "start": "parcel indexReact.html",    [DEVELOPEMENT PHASE]
    "build": "parcel build indexReact.html"
  },

we can use the scripts in the terminal as follows:-
  npm run start or npm start are the same
  but npm build will not work like this, you need to write npm run build

** React.createElement => creates a ReactElement which is a JS Object => when we render this, the ReactDOM converts it into an HTMLElement and pushes it into the browser (and replaces everything from that DOM element if there was anything earlier)

 a. const parent1 = React.createElement("div", { id: "parent" },"HII")
  it isn't easy to create elements like this
  so JSX came into play -- a convention where HTML and JS are merged into one file  (JSX and React are not related to each other, e.g.- "JSX is a part of React" this statement is wrong)
** JSX is not "HTML inside Javascript"
   it is simply an "HTML-like syntax" or "XML-like syntax"
 b. const parent1 = <h1 id="parent"> HII </h1>;  //here parent1 is a React element
a. is a React element created using React, b. is a React element created using JSX (both these are the same thing)
b. is not pure JavaScript, our browser does not understand JSX
  ES6(ECMAScript) is what the JS engine understands   
  so Parcel does the whole thing that is JSX is transpiled before it reaches the JS engine (this JSX is converted into the code that our browser or the React can understand)
    but Parcel is not doing the transpilation by itself, it is putting another package called Babel (another JS library, Babel is a JS compiler) into work for this purpose
Parcel is a manager of Babel

During transpilation, internally the JSX is converted into a React.createElement done by Babel, and further methods are followed as usual

const heading=<h1 id="heading" className="hello">hii everyone</h1>; //this is not HTML, in HTML the attribute is "class", whereas that same attribute in JSX is "className"
** If you have to give an attribute in JSX, you have to write it in CamelCase, in HTML we write tabindex="1" in JSX we write tabIndex="1"
const  root=ReactDOM.createroot(document.getElementById("root"));
root.render(heading);

for multiline JSX code, you have to wrap it inside parentheses(), in order to help Babel understand where JSX is starting and ending
const heading=(
    <h1 id="heading" className="hello">
        hii everyone
    </h1>
);


//components   
1. Class-based components - old way (uses JS classes)
2. Functional components - new way (uses JS functions) //normal javascript function which returns some JSX element

const head1 = ()=>{
    return <h1 className="heading"> Namaste React Functional Component </h1>;
};

const head2 = ()=> <h1 className="heading"> Namaste React Functional Component </h1>;

const head3 = ()=> (
    <h1 className="heading"> Namaste React Functional Component </h1>
);
** head1, head2, head3 are the same React component

** You cannot render a functional component just like a React Element
root.render(<head1/>); //this is how to render a functional component

//Component Composition - component inside another Component
const Heading = ()=>{
    return <div id="root">
        <head1/>              // you can also write <head1></head1>  and also {head1()} -> this is like calling the head1() function
        <h1>HII EVERYONE</h1>
    </div>;
};

** You can also write normal JS functions to create functional components

const elem = <span>Hello Javascript code</span>; // consider elem as just a normal javascript variable
const heading = (
    <h1 id="heading" className="hello">
        {elem}               //This is how you can put a React Element inside another React Element
        hii everyone
    </h1>
);
const num=1000;
const data=api.getData();
const Heading = ()=>{
    return <div id="root">
        {data}                // inside these curly braces you can write any JS code/expression inside JSX
        <h2>{num}</h2>        // it will show 1000
        {heading}             // you can also put React Elements inside a functional component like this
        <h1>HII EVERYONE</h1>
    </div>;
};
* You can also put functional components inside a React element, just like a component inside another component

** Cross-site scripting is the attack technique that allows attacker to run JS code to access everything on your browser
like they can steal ur local storage data, cookies, read data
  *  JSX takes care of this injection, If the malicious API passes data to your code JSX just escapes it (sanitizing the data)

-------------------------------------------------EPISODE 4--------------------------------------------------------------------------------

** For INLINE STYLING in JSX,it takes a JS object as an attribute
--------------------------------------

const stylecard={
    background-color:"yellow";
}                                   // this is a JS object

const Body = () => {
  return (
    <div className='body'>
      <div className='search'>Search</div>
      <div className='res-container' style={stylecard}>  //objects can be written within curly braces (JS code/expression are written within curly braces inside JSX)
        <RestCard />                         |
      </div>                                 |
    </div>                           //INLINE STYLING in JSX
  );
}

<div className='res-container' style={{background-color:"yellow";}}>   // writing the JS object directly
//first { } telling there is some piece of JS inside it and second { } is the JS obj itself

----REAL DATA is in JSON format----------

Conflict driven UI-open swiggy ->offers available in benguluru,kol all are different
so for not building diff UI for different places

Conflict comes from backend
---------------JSON------------------
{
"employee": {
"name": "sonoo",
"salary": 56000,
"married": true.
}
}
-----------------------------------------

swiggy api:https://www.swiggy.com/dapi/restaurants/list/v5?lat=12.9351929&lng=77.62448069999999&page_type=DESKTOP_WEB_LISTING

DURING USING MAP:
--------------------
we need to write key to uniquely identify the elements:

                  CONTAINER  
  ---------------------------------------                     
     |               |                |
1.component1    2.component2    3.component3
suppose you want to insert a component before component1 this is where key is important
key is also important as it will not re-render everything again,

When React renders a list of elements, it needs a way to uniquely identify each item in the list. The key prop provides 
a hint to React about the identity of each element. This is especially important when the list can dynamically change, such as 
when items are added or removed.

data.map((rest,index) => (
    <ResCard key={index} data={rest} />   //key is to identify each card as unique
))
//INDEX is not recommended by React itself

-------------------------------------------------EPISODE 5--------------------------------------------------------------------------------
src folder-has the source code
in src folder

ALL hard coded data like links and dummy data are placed in another folder called utils

Types of EXPORT/IMPORT 
1.default (Components)
-------export default (name)
--------import (name) from './filename'

2.Named (multiple exports)
--------export const name=
--------export const name2=
--------import {name} from './filename'


Default export can be done with the named export in thsi format:---------------
// Named export
export const myFunction = () => {
  // ... function implementation
};

// Default export
const MyComponent = () => {
  // ... component implementation
};

export default MyComponent;

onClick takes a call back function 
----------
onClick{()=>{}}


REACT HOOKS  (//import from react as a named import)

NOTE:when we change a normal variable it does not affect the UI so we use the hooks
are normal js function given by react which have super powers used for DOM manipulation
these are the utility function given by react.The two imp hooks are :useState() and useEffect()

useState()-basically gives u super power react variable  keeps sync of data layer and UI layer
const [listOfRestaurants, setListOfRestaurants] = useState(reslist);
           |                     |                         |
        default            what to be placed           default value[array of objects]
                           when an event occurs

setListOfRestaurants(filteredList);
means that listOfRestaurants=filteredList; after onCLick eventListerner

this will filter out those restaurants having rating more than 4 and sets the listOfRestaurants
This is called re-rendering. When a state variable changes react re-renders its omponents. As soon as the list of restaurants updates,
 react will very quickly removes the past data and updates with the new data.

 const arr=useState(reslist);     //array destructuring//useState is returning an array
 const listOfRestaurants=arr[0];
 const setListOfRestaurants=arr[1];

"const " data type actually we cannot change the value  but how it is possible?
When we update the value by assigning new value to setListOfRestaurants then the useState() actually rerenders the whole component 
so a new valu eis assigned to listOfRestaurants.
  

Reconciliation Algorithm(React Fibre)
------------------------------------------

Actual DOM              Virtual DOM is the representation of the actual DOM, it is nothing but an js object
<div>
  <div>
    <h1/>
  </div>
</div>

DIFF Algorithm
-----------------

It will actually cal the difference between the previous obj and the updated obj then it actuallys  changes the DOM and
renders it at every render cycle. whenever there is a change in state variable there is a change in DOM and react re-renders.

React is fast-> because it does efficient DOM manipulation-> in Virtual DOM

--------------------------------------------------------------EPISODE 6--------------------------------------------------------------------------------

Architecture---
------------------

1.MONOLITH Architecture (Suppose this is a JAVA PROJECT and we are doing everything in that project)

----------------------
| API   UI     AUTH   |  (JAVA PROJ)  (only writtern in java)
| DB     SMS          |
|---------------------|

2.MICROSERVICES

Different services for diff jobs    
---------------------------|
|                          |
|  |API|     |UI|   |DB|   |(theses services are independent of each other and interacts in some use cases)
|                          |     (ALl these small application are performed separately following separatio  of concerns (single responsibility principle))
|   |AUTH|   |SMS|         |
| ---------------- ------- |

HOW do these services interact with each other?
these services interact with each other through diff cases. They make call to diff microservices.
Our react project comes into UI  microservices. ADVANTAGE: is that UI can be writtern in react, backend can be writtern in mongodb 
so  mainly diff microservices can be writtern in different languages. They run in their own ports. eg UI:1234 , Backend:1022 and all these
ports are mapped to their domain name.  


TWO APPROACHES OF API CALL :
---------------------------------
1.
LOADS --> API CALL(takes 500ms)-->Renders it in UI
(as soon as the page loads we make an api call ,the api response and we render it )
(poor user experience as we need to wait for 500ms)

2.
LOADS --> RENDERS -->API CALL --->RE-RENDERS
(as soon as the page loads we render it then we make an api call ,the api response and we re-renders it )
(Best approach)

useEffect() hook 
-------------------------
it takes two arguments 1.callback function 2.dependency array
As teh body loads it loads the whole body as the render cycle gets over, it calls its callback function.(useEffect gets called after the component
has been rendered)

eg.
-----
useEffect(()=>{
  console.log("HII");
},[]);
 console.log("Ritu");

 console
 ----------
 Ritu
 HII

CORS: mainly our browser or local host restricts the use of another host

how to find api? : go to website ->inspect->network->click on fetch option->left side column api are given

Suppose instead of showing Loading page while the api does response and re-renders we can show shimmer UI which is basically the shadow of the whole
original UI.

const [button,setbutton]=useState("Login");
how const variable is changes?
so when we setbutton actually react ensures to find the diff between the previous vitual DOM and the modified virtual DOM and then re-renders the 
component once again, so again a new button variable is created with the modified value.

const [searchtext, setsearchtext] = useState("");
<input type='text' className='search-box' value={searchtext}></input>   
to keep track of the input we need to bind it with the local state variable .
NOTE: when at each keystroke the nothing shows in input text this is because .... the value is bind to seacrtext and the value is bind to input type
so at at change the value still remain ""

so we need to add onChange event handler :---that as the input changes we are changing the seachtext value
at each key stroke the react component gets render again and again
whenever a state variable updates,react tru=iggers a recoincilation cycle.

NOTE:
-------
const [listOfRestaurants, setListOfRestaurants] = useState([]);
const [filteredlistOfRestaurants, setfilteredListOfRestaurants] = useState([]);

we are keeping intact the main list of restaurants that is listOfRestaurants and on every change we are manipulating filteredlistOfRestaurants
so that the main list of restaurants keeps intact

--------------------------------------------------------------EPISODE 7--------------------------------------------------------------------------------
useEffect
------------
useEffect(()=>{})
1. if no dependency, then useEffect will be called at every render of the component.
2.useEffect(()=>{},[])if dependency is empty array, then useEffect will be called at first render of the component.
3.useEffect(()=>{},[btnname])if dependency is not an empty array, then useEffect will be called when the btnanme variable gets updated


useState
-----------

useState() is used to create local state variables inside your functional component
NOTE: do not create state variables inside conditional statements or for loop or functions.
------

npm react-router-dom is installed to access the router facility to enhance the multi-page concept
e.g if i write /about in url we will redirect to about us page

createBrowserRouter creates an Router configuration
--------------------- 
createBrowserRouter([{},{}]) takes a list of object where each object is given it s path and the element to be rendered at that specific path.

RouterProvider is used to provide the createBrowserRouter
----------------
import { createBrowserRouter,RouterProvider } from 'react-router-dom';
const appRouter=createBrowserRouter([
  {
    path:"/",
    element:<App/>
  },
  {
    path:"/about",
    element:<About/>
  }
])

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
 <RouterProvider route={appRouter}/>
);


Another approach:
-------------------

<Router>: This is a component from React Router that provides the routing context for your application. It must wrap the entire application to enable routing.

<Routes>: This component is used to define the routes for your application. Inside it, you specify the different routes using the <Route> component.

<Route path="/" element={<App />} />: This line defines a route for the root path ("/"). When the URL matches "/", it renders the <App /> component.
 The element prop is used to specify the component to render for the given route.

import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
 const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <Router>
    <Routes>
      <Route path="/" element={<App />} />
      <Route path="/about" element={<About />} />
    </Routes>
  </Router>
);


now suppose i want my header component to be a constant :
so 
import { createBrowserRouter,RouterProvider,Outlet } from 'react-router-dom';
const AppLayout =()=>{
  return(
    <div>
      <Header/>
      <Outlet/>
    </div>
  )
}
const appRouter=createBrowserRouter([
  {
    path:"/",
    element:<AppLayout/>,
    errorElement:<Error/>
    children:[
      {
    path:"/about",
    element:<About/>,
    errorElement:<Error/>
    },
    {
    path:"/contact",
    element:<Contact/>,
    errorElement:<Error/>
    }
  ]
 }
  
])

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
 <RouterProvider route={appRouter}/>
);

now when path "/" is rendered the <AppLayout/> is rendered in place of <Outlet/>
now when path "/about" is rendered the <About> is rendered in place of <Outlet/>
so the header component remains intact and below that we add the outlet....

by clicking on about it moves to about page using <a> anchor tag it reloads the whole page which is a bad practice so we use the <link> tag
from react-router-dom. It is a wrapper of teh <a> tag

Routing
----------
1.Client Side Routing -  we are not making any sort of network call, rather we are doing changing of components as about, contact 
component already loaded in your local host.When we go to aboutus page it loads the about component

2.Server Side Routing - When the local host, makes a network call fetches the data for AboutUS page and reloads the page.

Dynamic Routing :
where fr each restaurant another page will be created
path="/restaurant/:resId" so this resId  is dynamic

useParams from react-router-dom is used to find the id of the various dynamic routing.Params is a object with the unique id
e.g-http://localhost:3000/restaurants/78511 ,useParams fetches the id :78511

which further is used for dynamic routing

Dynamic Routing:
------------------
Dynamic routing refers to the practice of generating routes dynamically based on certain parameters or data
e.g:<Route path="/user/:userId" element={<UserProfile />} /> userId keeps chaging according to individual ids.


--------------------------------------------------------------EPISODE 8------------------------------------------------------------------------

CLASS BASED Component
-------------------------

 <UserClass name="Ritushree Das" location ="Address"/>
 ALl the props u have passed will bind into a single object ...

import React from "react";
import "./User.css";
class UserClass extends React.Component{
    constructor(props){
        super(props);        and then the obj will be passed to the Component
    }

    render(){
        return <div className="User-card">
            <div>NAME :{this.props.name}</div>
            <div>Location:{this.props.location}</div>
            <div>Contact Us:@ritz.das</div>
        </div>
    }
}

export default UserClass;

----------NOTE: we can also write ------------------
class UserClass extends React.Component {
  render() {
    return (
      <div className="User-card">
        <div>NAME: {this.props.name}</div>
        <div>Location: {this.props.location}</div>
        <div>Contact Us: @ritz.das</div>
      </div>
    );
  }
}

export default UserClass;
------------------------------------------------------------------------------------------------------------------

creating state variable is always inside constructor
---now when About.js is mounted/loaded in the web page it then goes through the jsx line by line and when it sees that the UserClass Component
is called an instance of component or the component is initialised.

LifeCycle
-----------
Parent Constructor-->Parent Render-->Child Constructor --->Child Render

componentDidMount(){
  console.log("HII MOUNT");
}

now first when UserClass is loaded the sequence of loading follows:
1.Constructor
2.render
3.componentDidMount
--------------------------------------------
now suppose if About.js is a class based component --->calling--->UserClass which is also a class Based component
Calling sequence---
1.Parent Constructor
2.Parent render
    1.UserClass is called (Child)
          1.child constructor
          2.child render
          3.child componentDidMount
3.Parent componentDidMount
------------------------------------------------
LIFECYCLE 
----------------
2PHASES:
1.render phase (is fast)
in render phase --first constructor called then render method

2.Commit phase (is slow)
after all the updation in DOM through render phase then DidMount is called
so DidMount is the place where API is called.

-------------MOUNTING CYCLE---------------
-Constructor(dummy data)
-Render (dummy data)
      <HTML dummy>
componentDidMount
      <API CALL>
      this.setstae--->state variable updated

----------UPDATING CYCLE------------
-   render(API data)
     <HTML (new api data)/>
-componentDidUpdate
--------------UNmounting cycle---------
-componentWillUnmount
       this will be called when we go to another page


----------------------------------------------------EPISODE 9---------------------------------------------------------------------------------


CUSTOM HOOKS
----------------
A user created Hook which is a utility function.
Naming convention:write the component starting with "use"

Now to move offline go to inspect-->network-->then in drop down no throtting to offline

----DYNMAIC BUNDLING--------
Dynamic bundling or chunking, often referred to as code splitting, is a technique used in web development to improve the performance
 and loading time of a web application. The idea is to split the JavaScript code into smaller "chunks" or "bundles" and load them on-demand, 
 instead of loading the entire JavaScript code at once. This is particularly useful for large-scale applications where the initial download size
  can be substantial.

  -----LAZY LOADING/(ON-demand Loading)----------
  Lazy loading is a technique used in web development to defer the loading of certain assets (such as images, scripts, or stylesheets) until they are
   actually needed.
   when our app loads the grocery does not loads, when we go to grocery at that point it loads
   -----Lazy() is a named export given by react
    -It takes a callback function calling import() function and inside import function taking the path of the grocery
    so making grocery having its own bundle and and the main bundle is different(app.js)
   ----Suspense------
    <Suspense fallback={<Shimmer />}><Grocery /></Suspense>
    Suspense is writtern as without it an error occurs as when our app loads it trys t load Grocery but cannot so we need to write suspense fallback 
    whick shows what to be loaded in absence of Grocery


------------------------------------------------------EPISODE 10---------------------------------------------------------------------------------
Other ways of writing css--
1.sass 2.scss 3.styled component
---------LIB-----------------------
MAterialUI library (in react)
ChakraUI 
Bootstrap
ant design
----------------------------------
Tailwind css works with various frameworks,normal HTML..and so on
Taiwind css usus postcss behind the scene .(Postcss is a tool for transforming js to css)

npx tailwindcss init -----it will create a taiwind.config.js
content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  telling tailwind can be used in js file,jsx file ans so on
  in tailwind, everything happens related to class name

  Dynamic classes in tailwing w-[200px]
  Disadvantage of taiwindcss-
  1. it makes the code look ugly
  2. it becomes messy to handle 

  Advantages--
  1.t is very light-weight 
  as if we write 10 times m-4 it jst take it as once

  -------------------------------------------------EPISODE 11_---------------------------------------------------------------------------------

  HIGHER ORDER COMPONENT--a function that returns another function

  it basically used for enhancement suppose in the body component we want some cards to be labelled as promoted by our app.
  NOTE: as promoted not in the API so making every rescard id which is divisible by 5 as promoted.... 



  ----UI APPLICATION-----
  1.UI LAYER
  2.DATA LAYER

  UI LAYER GETS POWERED BY DATA LAYERED
  (Data layer consits of props,state variables ...etc) (/*Major thing is to handle data layer*/)

  FILTER----out all the item categories and enhance the individual restaurant menu
  @ is not supported so we need to write ["@type"] or [@type]
  The format of the categories (UI) is called ---"Acordian

  ----REACT DEVELOPER TOOLS-----
  featues----
  1.Components
        it shows the component hierarchy of the system
  2.PROFILER
        it mainly records ur actions and after stop recording it shows the components invoked
  
  -----------CONTROLLED AND UNCONTROLLED Components--------LIFTING THE DATA-------------
    RestaurantMenu is controlling the Restaurant Category as for suppose there are 4 categories and suppose if we expand recommended category all 
    other categories must collapse.

    This is called lifting the data as the control is on the hands of the parent not in the child

    UNCONTROLLED---when restaurant category has its own state 

    CONTROLLED COMPONENT FULL EXPLANATION 
    -------------------------------------------
    RestaurantMenu.js(PARENT)
    -----------------------------

    const [showIndex,setShowIndex]=useState(0);
     {categories.map((category,index)=>(
                <RestaurantCategory key={category?.card?.card.title} 
                data={category?.card?.card} 
                showItems={index===showIndex?true:false}      //we are setting which category items to be showed 
                setShowIndex={()=>setShowIndex(index)}/>      
     ))}
     By default category 0 is always showed with their items as showIndex initially 0.
    showIndex is controlling which category to showed if category 0 is opened automatically other categories get closed 
    on clicking on other categories the setShowIndex function is called which returns set the showIndex with its index value then
    showItems gets equal to the actual index value and the index of the category  clicked which changes that particularly
    category to true which means that category will show its items and other will not show their items


    RestaurantCategory.js (CHILD)
    -------------------------------------

    const RestaurantCategory=({data,showItems,setShowIndex})=>{
        const handleClick=()=>{
          setShowIndex();
      }
      return (
        <div>
            <div className="flex justify-between cursor-pointer "onClick={handleClick}>
            {showItems&&<ItemList items={data.itemCards}/>}
        </div>
    )
 }

 Basically what happens on cLick of category it calls the setShowIndex() function which modifies the parent RestaurantMenu 

 LIFTING THE STATE UP ---PARENT CONTROLLING ITS CHILDREN

----------PROPS DRILLING--------------
 IN REACT,passing data through components is a tough work. So data flow is a one way. parent->children->children
 root->children->children->ans so on
 Now suppose I want to pass the data to the last children so we need to move the data between its intermediate parents.

 In that case we useContext  so that we can pass the data directly.
 Because COntext is an approach like a global data is placed and any one can access it when needed. 
 eg-logged in user info, or the theme (light or dark theme)

 createContext used for making a global data.
 useContext used for using the global data.
 const data=useContext(useContext);


 In class based components
 <userContext.Consumer>
 {(data)=>console.log(data)}       it takes a callback function which take data that the global data
 </userContext.Consumer>

 or more destructuring---
 <userContext.Consumer>
 {({loggedInUser})=>console.log(loggedInUser)}       it takes a callback function which take data that the global data
 </userContext.Consumer>

 ------To modify the data and make the data accesible to all the other components we use userContext.Provider ------
  const [userName,setUserName]=useState();
  useEffect=(()=>{
   //API CALL;
   const data={
    name="Akshay Saini"
   }
   setUserName(data.name);
  },[])
 <UserContext.Provider value={{userLoggedin:userName}}>
 <header/>
 <outlet/>
 </UserContext.Provider value={{userLoggedin:userName}}>

Header component and other components inside the Provider can access the modified value;
NOTE: it is very powerful as we can apply provider to somecomponents or the whole app.

------------------------------------------------------------------------------
const [username,setusername]=useState();
<UserContext.Provider value={{ loggedInUser:username,setusername }}>   //we can pass setusername so that we can access it anywhere
      <Router>
        <Header />
        <Routes>
        .
        .
        .

Body.js
--------

const {loggedInUser,setusername}=useContext(UserContext);
<input className='border border-black p-2 ' value={loggedInUser} onChange={(e)=>setusername(e.target.value)}></input>
so  now on every change of key stroke the loggedInUser changes.

-----------------------------------------------------------------------
usecontext and Redux Toolkit Different
===============================================
redux is more scalable 
in useContext we need to make diff context for different types of data.

State Management:

useContext:
------------
Primarily designed for managing local component state or sharing state between a few closely related components.
State is managed within the component or a few related components.

Redux:
------
Designed for managing a global state that can be accessed by any component in the application.
State is stored centrally in a Redux store, and components can subscribe to changes in the state.


-------------------------------------------------------------------EPISODE 12------------------------------------------------------------------
-------------------REDUX----------------------------------------
--------Works in the data Layer-----------------------
NOTE:REDUX AND REACT ARE DIFF LIB.
REDUX is a lib used for managing state. (Another lib is zustand)
Application becomes easier for debugging
              TWO LIB
                 |
        -  - - -----------
        |                 |
        React-Redux     Redux-Toolkit(packages are intended to be 
                                        the standard way of writing redux logic)

VANILLA REDUX IS THE OLDER REDUX(WHICH SAYS DON'T MUTATE STATE)
--------REDUX STORE---------
we can keep all the data in our redux store but slice wise .Slices can be (one is cart data slice),(other is loggedin user slice)

CART button  (Click) ----->Dispatches an action---->calls a function---->which internally modifies the cart(slice)(updates the slice)
-------------
What is the function?
this is called as reducer function.

Now how to read data from the cart slice in the redux store??
--------->from cart slice---->|Selector|----------->that reads the data ------->modifies the cart component.
                |SELECTOR|------>(phenomenon is called subscribing to the store)(our header component have subscribed the store)
npm i @redux/toolkit 
npm i react-redux

-Build a store         ----configureStore()
-Connect the store to our app  ----------------<Provider store={}> 
-Cart (cartSlice)          ---------------------createSlice
-dispatch(Action)                 ---------------------reducers
-Selector     ----is nothing but a react hook ----useSelector

const handleItems=(items)=>{

}
onClick={()=>handleItems(items)}//correct way
onClick={handleItems(items)}//NOT correct as we do not want to immediate call a function but call it when clicked

-----------------------------------
const cartItems=useSelector((store)=>store.cart.items);//from the store we are only subscribing to a slice

or
const store=useSelector((store)=>store)//subscribe to the whole store
const cartItems=store.cart.items;

note: not an effictive one as we donnot need any sort of update for other slice rather than cart SLice
-----------------------------------------

in appstore the slices are kept in 
reducer:{
  cart:cartReducer
}

in cartSlice 
the reducer functions are kept in
reducers:{
  //mutating state directly, donot have to return and redux uses immer behind the scenes
  addItem:(state,action)=>{     //state is a local var having value of initialState

      state=["akhshay"]     //not mutating jst adding a another reference to the state

      state.items.push()     //mutating the state
  }
}

but we export the cartSlice.reducer;

reducers:{
  clearCart:(state,action)=>{ 

    //in redux we cannot do simply console log--we need to use current
    state=[];
    console.log(current(state));
    //either update the existing state or return the new state
      state.items.length===0;
  -------OR----------
      return {items:[]}
  }
}

-----------------------------------------------------------EPISODE 13-------------------------------------------------------------------------
TESTING
------------

Types of testing (Developers can do):
1.Manual Testing --which mainly we focus whether the functionality is working fine or not according to the code.
(we particularly see the functionality of the specific type but not the whole application)

(So to check the whole application where a single line of code causes error for other functionalities or not)
2.writing Test cases---that automatically tests our whole application.

    -Unit Testing                ----(only one specific component)
    -Integration testing              -----------(test the flow of data and control between diff components that will lead to some result)
    -End to end testing(e2e testing)    ---------------(User lands on the page...and actions performed --to user leaving the page)

   NOTE   ::::: Developers are responsible for unit testing and Integration testing

---use React-testing library to write test cases in React
(React testing lib is build on DOM testing LIB)
React testing lib takes "jest" delightful js framework 

-------INSTALLING PROCEDURE--------
install--1.react-testing lib  2.jest
now install jest working with Babel
if we config babel and parcel has its diff babel config behind the scenes so that will conflict ....
so we need to go to parcel then js then using other tools and write parcel.rc  basically to disable default babel transpilation
then perforn npx jest --init
install jsdom library
-----------------------------------------------------------------EPISODE 14---------------------------------------------------------------------------------------
NOTE:
-----------------------------------
LIB -FORMIK for validation of forms
--------------------------------
IN FORM:
 <form onSubmit={(e)=>e.preventDefault}/>do this as if not done it tries to submit the form automatically which refreshes our page 
 ,so to prevent it we do e.preventDefault

--------------------------USEREF --------------------------
To capture the email entered or password we can create individual state variable and onChange the value of the variable changes and then bind the 
valu of the input with the state variable
Other way:  is to use ref of the input
--------
This is where useRef () hook comes to the picture

const email=useRef(null);

<input ref={email}---------/>
<button onClick={()=>console.log(email.current.value)}

----FIREBASE AUTHENTICATION-------------

1.create a project
2.web and all actions and write the code in firebase.js according to instructions
3.go to authentication and enable email/password
4.then go to authentication doc and to to password auth then move to create password 
  -there is a satement of auth which needs to ba writtern onced as it is used everywhere so write it in firebase.json
5. write the logic of sign in and sign up
6.Make a redux store of user slice -----
6.1.For authentication handling go to onAuthChange of firebase authentication docs(manage users)
     - onAuthChange handles whenever there is a change in the user details
7.In useEffect {
  write the logic of auth change and in sign in addUser to the redux store(Body.js)
  and in sign out remove User from redux store
}

8.now in header do a sign out button and oncClick a event occurs
that from firebase docs go to password authentication and go to sign out logic and if sign out navigate to home page(Header.js)

9.To update teh name of the user ...go to mange users and update user profile if sign up is done correctly.
and once update then navigate (Login.js)

10. useSelector to fetch the icon from the redux store and dispaly only if the user is not null
11.Bug---in signup the icon was not updating 
    -So made the dispatch addUser after the profiel goth updated --- from auth.currentUser which consistes the current user


------------------------------------------------------------EPISODE 15 & 16-----------------------------------------------------------------------------
FIXING BUG-
--------------

when we are in / home page or login page changing the url to /browse we used to navigate which is not right .and if after the sign in user wants to go the 
login page do not allow...

SOLVING   :replacing the onaUth change to the header component as we know header is present everywhere so useEffect works fine in that as everytime
-----------             there is a change or reload the header is very everywhere so once sign in /sign up it takes us to the browse page and after sign out
                            it takes to login in page

in useEffect() return the function as when called
because when the component unmounts we donot want any sort of change.

TMDB --movie database
  -Login
   -Edit profile
   -API (left side)   find ur api key and api access token

go to movie list -now playing---on demo code const options is mandatory to pass everytime so keep it in constants.
   NOTE::::::::      ALL the aPi calls happen as we wrap our APP in strictmode
------------------
Why happens twice?React does extra rendering to check the consistency of ur data

Browser
-------

-MAIN CONTAINER
  -VideoBackground
  -Video title
-SECONDARYCONTAINER
 -MovieList *n
 -cards *n

 NOTE: there can be multiple trailers of one movie or no trailer if no trailer take the first vid of that particular movie and it trailer exits take trailer

 --MOVIElIST :POPULAR
      -MOVIECARDS *N
 ---mOVIELIST:NOW playing
  |
  |
  |
  |
  (N)

  Do tmdb image URL to get the CDN url


  OPENAI:platform.openai
  npm open ai---helper func to make api call directly
  then after using console(gptresult.choices)

  then go to tmdn search movies....and fetch the search api to fetch the individual details of the suggested movies'

  .env  file all the secret keys are kept ---with REACT_APP at the starting

  when we are clicking on gpt search or homepage we are making api call where our movies are already had the trailer vid
  so we use memoization , to prevent refetching

  const nowPlayingMovies=useSelector(store=>store.movies.nowPlayingMovies);
  useEffect(()=>{

        //memoisation   
        !nowPlayingMovies && getNowPlayingMovies();
    },[])

    NOTE: we can tell user to give their open ai key and the users can use it instead of using our key---(implement in ur upcomming projects)
    ---------Responsiveness-----
  default :mobile(small screen )
    sm: greater than small screen  (tab)
    md :greater thann meduim screen(desktop)


    -------------------------------------------------BONUS 1 && 2----------------------------------------------------------------------------------
    Machine Coding Interview Round
    ------------------------------------

    1.Requirements (on the topic: what features to be added)
    2.Tech Stack(UI layer:Tailwind css  DataLayer:React,react-router-dom,Redux and so on---)
    3.Planning of the structure of our app(visualisation)

    ReportWebVitals
    ------------------
    Web Vitals are a set of useful metrics that aim to capture the user experience of a web page. In Create React App, a third-party library is used
     to measure these metrics (web-vitals). 

    strictmode--React's Strict Mode is a development mode only feature for highlighting potential problems in an application. It helps to identify unsafe 
    lifecycles, legacy API usage, and a number of other features.


    GRID IN CSS- the whole grid is basically divided into 12 grid section 

    AXIOS---fetching---for json handling

NOTE:::::::::::
  IN UTUBE : SEARch apis then search api key utube auth
    IN GCP while making api key---(GO to lib and enable the utube v3 api) to access the token ( so that it works)

    Header remains same:In BOdy only the watchPage,Maincontainer Changes so keet it in Children 
    and do <Outlet/> after SIdebar in the Body.js


    const [searchParams] = useSearchParams(); is given if not using normal params---/watch?v=

    it is native browser search params;;;
    we do v.get()   //as v was the name of the id

    Debouncing---
    suppose with every key stroke the api is getting an api call 

    key-i 
    render the component 
    call the useEffect
    start the timer -make an api call after 200ms

    key-ip
    destroy the component (useEffect return Method)
    re-render the component 
    call the useEffect
    start the timer -make an api call after 200ms


    //--in searching if we search the same keyword again it will not make an API call
    //we use redux to do it.


    ----------------------------------------------BONUS 3----------------------------------------------------------------------------------------
    Live Chat ---Challenges face::---
    1.Get Live Data (Data Layer )
    2.UI Layer update (UI Layer)

    Live Chat 
    --Each comment is a div but when we comment comes it appends the new div ...
    --this may lead to heavy weight of the HTML--
    we need to handle the complications as well as the the UI experience

    Two ways we can update the Live Data---
    1.web socket (It creates an handshake between the UI and Server)(Bi-directional Live data)(No interval)
        They are Heavy we do not need it.(eg-trading,websockets)
    2.Long polling /(API polling) Ui requests  the Server and server send the data to the client. After the some interval it checks whether new data
         has arrived or not
          EG: Gmail,Utube live chat

  UI experience---
  that if after sometime it starts deletes the the live comments..it holds only a upto a certain length

  //Infinte scroll Working::::::
  Like OnScroll event -->we are making an api call an updating the redux store by appending the videos at the end.




  --------------------------------------------------------------------BONUS 4----------------------------------------------------------------------------------------

  useMemo
  ----------

useMemo is a React Hook that lets you cache the result of a calculation between re-renders.

const cachedValue = useMemo(calculateValue, dependencies)
--------------------------------------------------------------
CODE
-------------------------------------------------------------
const Demo = () => {
  const [text, setText] = useState(0);
  const [isDarkTheme, setIsDarkTheme] = useState(false);

  // const prime = findPrime(text);
  const prime = useMemo(() => findPrime(text), [text]);

  return (
    <div
      className={
        "m-4 p-2 w-96 h-96 border border-black " +
        (isDarkTheme && "bg-gray-900 text-white")
      }
    >
      <div>
        <button
          className="m-10 p-2 bg-green-200"
          onClick={() => setIsDarkTheme(!isDarkTheme)}
        >
          Toggle
        </button>
      </div>
      <div>
        <input
          className="border border-black w-72 px-2"
          type="number"
          value={text}
          onChange={(e) => setText(e.target.value)}
        />
      </div>
      <div>
        <h1 className="mt-4 font-bold text-xl">nth Prime : {prime}</h1>
      </div>
    </div>
  );
};
export default Demo;
---------------------------------------------------------------------------
EXPLANATION
------------
So finding nth prime number is a heavy operation so at every change in value in input box our component re-renders.So when we add the toggle 
effect of dark and light theme it similarly re-renders the component and calls nth prime methos which is not required ...Which effects the user experience
and lags our browser experience.

so when we are doing toggle of dark and light theme, we donot need to call the nth prime method, so call the method when there is a change in the 
input text..So we useMemo()

const prime = useMemo(() => findPrime(text), [text]);

useCallback()
----------------
useCallback is a React Hook that lets you cache a function definition between re-renders.

const cachedFn = useCallback(fn, dependencies)

useRef()
-------------
useRef is a React Hook that lets you reference a value that’s not needed for rendering.

const ref = useRef(initialValue)

CODE
-------
mport { useRef } from 'react';

function MyComponent() {
  const intervalRef = useRef(0);
  const inputRef = useRef(null);
  //print this value
  console.log(intervalRef.current.value)
  return(
    <input ref={intervalRef}/>
  )

}


Differnce between useRef,useState ,lets-
----------------------------------------------

const [y, setY] = useState(0);
  let x = 0;

  const ref = useRef(0);
  /** not like => ref = 0
   * ref = { current: 0 }
   *
   *
   * */

  console.log("Rendering....");

//for let
------------
  <button
          onClick={() => {
            x = x + 1;
            console.log("x=" + x);
          }}
        >
          Increase x
        </button>
        <span className="font-bold text-xl">Let = {x}</span>

//for useState
--------------------
<button
          onClick={() => {
            setY(y + 1);
          }}
        >
          Increase Y
        </button>
        <span className="font-bold text-xl">State = {y}</span>

//for ref
--------------
<button
          onClick={() => {
            ref.current = ref.current + 1;
            console.log("ref=", ref.current);
          }}
        >
          Increase Ref
        </button>
        <span className="font-bold text-xl">Ref = {ref.current}</span>

Output:
-----------
1. Click on let button in DOM----- NO CHANGE----
But in console value changes
NOTE: but on every re-render it starts the value again from its initial value i.e 0
------

2. Click on state button the components re-renders and changes the value of the Y

3. Click on ref button ---no change in the DOM ----(UI)
but in console the value changes
NOTE: but on every re-render it do not  starts the value again from its initial value rather it updates the UI and starts the previous value
-----     where it left 



